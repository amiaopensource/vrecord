#!/usr/bin/env bash

# vrecord
# Open-source software for capturing a video signal and turning it into a digital file.

VERSION="2020-08-05"
SCRIPTNAME="$(basename "${0}")"
SCRIPTDIR="$(dirname "${0}")"
CONFIG_FILE="${HOME}/.${SCRIPTNAME}.conf"
RUNTYPE="record"
SAT_OUTLIER_THRSHLD=14
AUD_OUTLIER_THRSHLD=10
BRNG_OUTLIER_THRSHLD=14

_usage(){
    cat <<EOF
${SCRIPTNAME} ${VERSION}

${SCRIPTNAME} will record a file via ffmpeg and the the Blackmagic SDK or
AVFoundation. It is an interactive script and will create 10 or 8-bit video
files.

Dependencies: cowsay, amiaopensource/amiaos/decklinksdk,
  amiaopensource/amiaos/ffmpegdecklink, amiaopensource/amiaos/gtkdialog, and
  xmlstarlet
Optional Dependencies: deckcontrol, gnuplot, mediaconch, mkvtoolnix, mpv, qcli

Usage: ${SCRIPTNAME} [ -g | -e | -r | -p | -a | -x | -v | -h ] [IDENTIFIER]

  IDENTIFIER will be used for the filenaming of the output files. It is only
  required in record mode.

  -g  use the GUI
  -e  edit the configuration file before recording
  -r  enable record mode [default]
  -p  enable passthrough mode where the video signal coming into the computer
      can be monitored, but not written to a file. Useful for testing equipment
      and setting up a tape to bars.
  -a  enable audio passthrough mode. Identical to passthrough except for the
      addition of audio bars. Note: Will eventually lag and crash if left on
      too long.
  -x  reset the configuration: this will replace the default configuration file
      at '${CONFIG_FILE}' with an empty one.
  -v  Run ffmpeg with '-loglevel debug'. Using this option creates a very large
      log file, so avoid using this option with 'Visual + Numerical' or any
      playback option that display the log as part of the view.
  -h  display this help menu

Advanced options
  -I  Provide a string of input options for the recording ffmpeg to use.
      For example "vrecord -I '-loglevel trace'" would force an ffmpeg logging
      level that is usually unaccessible via vrecord preferences.
  -O  Provide a string of output options for the recording ffmpeg to use.
  -i  Provide a file as an input to vrecord, rather than using the decklink
      device. For testing without a decklink device.
  -G  Share warnings from gtkdialog and vrecord, otherwise there are suppressed
      by default.
  -c  Provide a recording configuration file, rather than the default one at
      '${CONFIG_FILE}'.

See also the man page: man ${SCRIPTNAME}
EOF
}

# local functions
_get_iso8601(){
    date +%FT%T
}

_report(){
    local RED="$(tput setaf 1)"    # Red      - For Warnings
    local GREEN="$(tput setaf 2)"  # Green    - For Declarations
    local BLUE="$(tput setaf 4)"   # Blue     - For Questions
    local NC="$(tput sgr0)"        # No Color
    local COLOR=""
    local STARTMESSAGE=""
    local ECHOOPT=""
    OPTIND=1
    while getopts "qdwstn" opt ; do
        case "${opt}" in
            q) COLOR="${BLUE}" ;;                        # question mode, use color blue
            d) COLOR="${GREEN}" ;;                       # declaration mode, use color green
            w) COLOR="${RED}" ;;                         # warning mode, use color red
            s) STARTMESSAGE+=([${SCRIPTNAME}] ) ;;       # prepend scriptname to the message
            t) STARTMESSAGE+=($(_get_iso8601) '- ' ) ;;  # prepend timestamp to the message
            n) ECHOOPT="-n" ;;                           # to avoid line breaks after echo
        esac
    done
    shift "$((OPTIND-1))"
    MESSAGE="${1}"
    echo ${ECHOOPT} "${COLOR}${STARTMESSAGE[@]}${MESSAGE}${NC}"
}
_report_unexpected_error(){
    ERROR_VAR_NAME="${1}"
    ERROR_VAR_VALUE="${!1}"
    ERROR_DETAIL="$2"
    _report -d -wt "vrecord exited a form in an unexpected way (${ERROR_VAR_NAME}=${ERROR_VAR_VALUE}), please report this error to https://github.com/amiaopensource/vrecord/issues"
    if [[ -n "${ERROR_DETAIL}" ]] ; then
        _report -d -wt "Error details: ${ERROR_DETAIL}"
    fi
    if [[ -f "${INGESTLOG}" ]] ; then
        _writeingestlog "vrecord command Error" "invalid ${ERROR_VAR_NAME} value of ${ERROR_VAR_VALUE}"
    fi
    exit 1
}

# command-line options to set media id and original variables
OPTIND=1
while getopts ":hc:erpaxgvI:O:i:G" opt ; do
    case "${opt}" in
        h) _usage ; exit 0 ;;
        c) CONFIG_FILE="${OPTARG}" ;;
        e) RUNTYPE="edit" ;;
        r) RUNTYPE="record" ;;
        p) RUNTYPE="passthrough" ;;
        a) RUNTYPE="audiopassthrough" ;;
        x) RUNTYPE="reset" ;;
        g) RUNTYPE="GUI" ; GUI=1 ;;
        v) VERBOSE="true" ;;
        I) EXTRAINPUTOPTIONS=(${OPTARG}) ;;
        O) EXTRAOUTPUTOPTIONS=(${OPTARG}) ;;
        i) ALT_INPUT="${OPTARG}" ;;
        G) VERBOSE_GTKDIALOG="Y" ;;
        :) _report -w "Option -${OPTARG} requires an argument" ; _usage ; exit 1 ;;
        *) _report -w "Error: bad option -${OPTARG}" ; _usage ; exit 1 ;;
    esac
done
shift "$((OPTIND-1))"
ID="${1}"

_parse_report(){
    KEY="${1}"
    REPORT="${2}"
    echo "${REPORT}" | grep -i "^[ ]*${KEY}:" | cut -d : -f 2- | awk '{$1=$1;print}'
}

_maketemp(){
    if [[ "${1}" ]] ; then
        EXT="${1}"
    else
        EXT=""
    fi
    echo "$(mktemp -q "/tmp/$(basename "${0}").XXXXXX")${EXT}"
}
VRECORD_INPUT_TMP="$(_maketemp .vrecord_input.log)"

# manage an include file to pass variables to gtkdialog
VRECORD_VARS_FILE="/tmp/v_$(echo "${0}" | sed -e "s/[^A-Za-z0-9.]/_/g")_variables.txt"
_include_var(){
    while [[ "${@}" != "" ]] ; do
        VAR_NAME="${1}"
        VAR_VALUE="${!1}"
        shift
        echo "${VAR_NAME}=\"${VAR_VALUE}\"" >> "${VRECORD_VARS_FILE}"
    done
}
if [[ -f "${VRECORD_VARS_FILE}" ]] ; then
    . "${VRECORD_VARS_FILE}"
else
    _include_var VRECORD_VARS_FILE
fi

_setup_env_variables(){
    # Set variables for system differences
    QUERY_OS_TYPE="$(uname -s)"
    if [[ "${QUERY_OS_TYPE}" = "Darwin" ]] ; then
        OS_TYPE="macOS"
        if [[ $(dirname "$(command -v "${0}")") = "/usr/local/bin" ]] ; then
            if [[ -d "/usr/local/opt/vrecord" ]] ; then
                RESOURCE_PATH="/usr/local/opt/vrecord"
            else
                RESOURCE_PATH="$(brew --prefix vrecord)"
            fi
        else
            RESOURCE_PATH="${SCRIPTDIR}/Resources"
        fi
        if [[ -f "/Library/Fonts/Andale Mono.ttf" ]] ; then
            DEFAULTFONT="/Library/Fonts/Andale Mono.ttf"
        elif [[ -f "/System/Library/Fonts/Supplemental/Andale Mono.ttf" ]] ; then
            DEFAULTFONT="/System/Library/Fonts/Supplemental/Andale Mono.ttf"
        elif [[ -f "/System/Library/Fonts/Monaco.dfont" ]] ; then
            DEFAULTFONT="/System/Library/Fonts/Monaco.dfont"
        elif [[ -f "/Library/Fonts/Microsoft/Lucida Console.ttf" ]] ; then
            DEFAULTFONT="/Library/Fonts/Microsoft/Lucida\Console.ttf"
        elif [[ -f "/Library/Fonts/LetterGothicStd.otf" ]] ; then
            DEFAULTFONT="/Library/Fonts/LetterGothicStd.otf"
        else
            _report -wt "vrecord can't find a preferred font to use, please report this error to https://github.com/amiaopensource/vrecord/issues"
        fi
        HARDWARE_REPORT="$(system_profiler SPHardwareDataType)"
        COMPUTER_MODEL_NAME="$(_parse_report "Model Name" "${HARDWARE_REPORT}")"
        COMPUTER_MODEL_ID="$(_parse_report "Model Identifier" "${HARDWARE_REPORT}")"
        COMPUTER_PROCESSOR_NAME="$(_parse_report "Processor Name" "${HARDWARE_REPORT}")"
        COMPUTER_PROCESSOR_SPEED="$(_parse_report "Processor Speed" "${HARDWARE_REPORT}")"
        COMPUTER_PROCESSOR_COUNT="$(_parse_report "Number of Processors" "${HARDWARE_REPORT}")"
        COMPUTER_MEMORY="$(_parse_report "Memory" "${HARDWARE_REPORT}")"
        COMPUTER_SERIAL="$(_parse_report "Serial Number (system)" "${HARDWARE_REPORT}")"
        CORE_COUNT="$(_parse_report "Total Number of Cores" "${HARDWARE_REPORT}")"
        OPEN_COMMAND="open"
        ZCAT_COMMAND="gzcat"
        DECKLINK_DRIVER_PLIST="/Library/Extensions/DeckLink_Driver.kext/Contents/Info.plist"
        VIDEO_CARD_DRIVER_VERSION="$(defaults read "${DECKLINK_DRIVER_PLIST}" CFBundleVersion)"
        DIR_SELECTION_DIALOG="Select an existing folder (or drag/drop one below). File System/Volumes for external media."
    elif [[ "${QUERY_OS_TYPE}" = "Linux" ]] ; then
        OS_TYPE="linux"
        if [[ $(dirname "$(command -v "${0}")") = "/usr/local/bin" ]] ; then
            if [[ -d "/home/linuxbrew/.linuxbrew/opt/vrecord" ]] ; then
                RESOURCE_PATH="/home/linuxbrew/.linuxbrew/opt/vrecord"
            else
                RESOURCE_PATH="$(brew --prefix vrecord)"
            fi
        else
            RESOURCE_PATH="${SCRIPTDIR}/Resources"
        fi
        DEFAULTFONT="/usr/share/fonts/truetype/liberation/LiberationSans-Regular.ttf"
        if [[ ! -f "${DEFAULTFONT}" ]] ; then
          _report -wt "vrecord can't find a preferred font to use, please report this error to https://github.com/amiaopensource/vrecord/issues"
        fi
        HARDWARE_REPORT=$(lscpu)
        COMPUTER_MODEL_NAME="$(_parse_report "Model Name" "${HARDWARE_REPORT}")"
        CORE_COUNT="$(nproc --all)"
        OPEN_COMMAND="xdg-open"
        ZCAT_COMMAND="zcat"
        DIR_SELECTION_DIALOG="Select an existing folder (or drag/drop one below)."
    else
        echo "Unsupported OS, ${QUERY_OS_TYPE}, detected. Exiting."
        exit 1
    fi
}
if [[ -z "${OS_TYPE}" ]] ; then
    _setup_env_variables
    _include_var OS_TYPE RESOURCE_PATH DEFAULTFONT CORE_COUNT OPEN_COMMAND ZCAT_COMMAND COMPUTER_MODEL_NAME DIR_SELECTION_DIALOG
    if [[ "${OS_TYPE}" = "macOS" ]] ; then
        _include_var COMPUTER_MODEL_ID COMPUTER_PROCESSOR_NAME COMPUTER_PROCESSOR_SPEED COMPUTER_PROCESSOR_COUNT COMPUTER_MEMORY COMPUTER_SERIAL
    fi
fi

_gather_ffmpeg_vars(){
    CAPTURELOGSUFFIX="_vrecord_input.log"
    TIMECODELOGSUFFIX="_frame_timecodes.txt"
    if [[ -d "/usr/local/opt/ffmpegdecklink" ]] ; then
        BREW_PREFIX="/usr/local/opt/ffmpegdecklink"
    elif [[ -d "/home/linuxbrew/.linuxbrew/opt/ffmpegdecklink" ]] ; then
        BREW_PREFIX="/home/linuxbrew/.linuxbrew/opt/ffmpegdecklink"
    else
        BREW_PREFIX="$(brew --prefix ffmpegdecklink 2>/dev/null)"
    fi
    if [[ -d "${BREW_PREFIX}/bin" ]] ; then
        FFMPEG_BIN="${BREW_PREFIX}/bin/ffmpeg-dl"
        FFPLAY_BIN="${BREW_PREFIX}/bin/ffplay-dl"
        FFPROBE_BIN="${BREW_PREFIX}/bin/ffprobe-dl"
    else
        FFMPEG_BIN="$(which ffmpeg)"
        FFPLAY_BIN="$(which ffplay)"
        FFPROBE_BIN="$(which ffprobe)"
    fi
}

if [[ -z "${FFMPEG_BIN}" ]] ; then
    _gather_ffmpeg_vars
    _include_var CAPTURELOGSUFFIX TIMECODELOGSUFFIX BREW_PREFIX FFMPEG_BIN FFPLAY_BIN FFPROBE_BIN
fi

_cleanup(){
    _report -wt "Vrecord is being stopped at $(_get_iso8601), noting this in the capture log."
    _writeingestlog "exit status" "vrecord was forced to quit early at $(_get_iso8601). Some processing may be incomplete."
}

_check_mpv(){
    if ! mpv > /dev/null ; then
        mpv
        _report -wt "mpv doesn't appear to be running correctly. Try 'brew reinstall mpv'."
        exit 1
    fi
}

SHARED_FUNCTIONS_FILE="${RESOURCE_PATH}/vrecord_functions"
. "${SHARED_FUNCTIONS_FILE}"

# optional dependency checks
BMDTOOLS_INSTALLED="$(if command -v bmdcapture >/dev/null ; then echo true ; else echo false ; fi)"
DECKCONTROL_INSTALLED="$(if command -v deckcontrol >/dev/null ; then echo true ; else echo false ; fi)"
GNUPLOT_INSTALLED="$(if command -v gnuplot >/dev/null ; then echo true ; else echo false ; fi)"
MEDIACONCH_INSTALLED="$(if command -v mediaconch >/dev/null ; then echo true ; else echo false ; fi)"
MKVPROPEDIT_INSTALLED="$(if command -v mkvpropedit >/dev/null ; then echo true ; else echo false ; fi)"
MPV_INSTALLED="$(if command -v mpv >/dev/null ; then echo true ; else echo false ; fi)"
QCLI_INSTALLED="$(if command -v qcli >/dev/null ; then echo true ; else echo false ; fi)"

if [[ -f "${CONFIG_FILE}" ]] ; then
    . "${CONFIG_FILE}"
    # set defaults if not set by config file
    if [[ -z "${FFV1_SLICE_CHOICE}" ]] ; then
        FFV1_SLICE_CHOICE="16"
    fi
    if [[ -z "${DECKLINK_UTILITY_CHOICE}" ]] ; then
        DECKLINK_UTILITY_CHOICE="ffmpeg"
    fi
else
    _report -d "Initiatizing the configuration file at ${CONFIG_FILE}."
    RUNTYPE="edit"
fi

_gtk_vbox_list() {
    VARIABLE_NAME="${1}"
    WIDTH="${2}"
    LABEL="${3}"
    shift 3
    OPTION_LIST=("${@}")
    SELECTION="$(_get_index_of_value "${!VARIABLE_NAME}" "${OPTION_LIST[@]}")"
    if [[ "${VARIABLE_NAME}" == "DECKLINK_INPUT_CHOICE" ]] ; then
        LIST="<input>_get_decklink_inputs</input>"
    elif [[ "${VARIABLE_NAME}" == "AVFCTL_INPUT_CHOICE" ]] ; then
        LIST="<input>_get_avfctl_input_list</input>"
    else
        LIST="$(_expand_list2items "${OPTION_LIST[@]}")"
    fi

    _get_list_extras(){
        if [[ "${VARIABLE_NAME}" == "VIDEO_CODEC_CHOICE" ]] ; then
            echo '<action condition="command_is_true( [ \"$VIDEO_CODEC_CHOICE\" = \"FFV1 version 3\" ] && echo true)">enable:FFV1_SLICE_CHOICE</action>
                  <action condition="command_is_true( [ \"$VIDEO_CODEC_CHOICE\" != \"FFV1 version 3\" ] && echo true)">disable:FFV1_SLICE_CHOICE</action>
                  <action type="refresh">VRECORD_OUTPUT_NAME</action>'
        elif [[ "${VARIABLE_NAME}" == "CONTAINER_CHOICE" ]] ; then
            echo '<action condition="command_is_true( [ \"$CONTAINER_CHOICE\" = \"Matroska\" ] && echo true)">enable:EMBED_LOGS_CHOICE</action>
                  <action condition="command_is_true( [ \"$CONTAINER_CHOICE\" != \"Matroska\" ] && echo true)">disable:EMBED_LOGS_CHOICE</action>
                  <action type="refresh">VRECORD_OUTPUT_NAME</action>'
        elif  [[ "${VARIABLE_NAME}" == "AUDIO_MODE_CODEC_CHOICE" ]] ; then
            echo '<action type="refresh">VRECORD_OUTPUT_NAME</action>'
        elif  [[ "${VARIABLE_NAME}" == "DECKLINK_UTILITY_CHOICE" ]] ; then
          echo '<action condition="command_is_true( [ \"$DECKLINK_UTILITY_CHOICE\" = \"bmdcapture\" ] && echo true)">disable:TIMECODE_CHOICE</action>
                <action condition="command_is_true( [ \"$DECKLINK_UTILITY_CHOICE\" != \"bmdcapture\" ] && echo true)">enable:TIMECODE_CHOICE</action>
                <action type="refresh">VRECORD_OUTPUT_NAME</action>'
        fi
    }

    _get_vbox_extras(){
        if [[ "${VARIABLE_NAME}" == "TIMECODE_CHOICE" ]] ; then
            echo "
            <button>
                <label>Scan timecode types</label>
                <action>_update_config_file</action>
                <action type=\"exit\">timecode_scan</action>
            </button>"
        elif [[ "${VARIABLE_NAME}" == "EMBED_LOGS_CHOICE" ]] ; then
            echo "<sensitive>$(if $MKVPROPEDIT_INSTALLED ; then echo true ; else echo false ; fi)</sensitive>"
        elif [[ "${VARIABLE_NAME}" == "QCTOOLSXML_CHOICE" ]] ; then
            echo "<sensitive>$(if $QCLI_INSTALLED ; then echo true ; else echo false ; fi)</sensitive>"
        elif [[ "${VARIABLE_NAME}" == "DECKLINK_INPUT_CHOICE" ]] ; then
            echo "
            <button>
                <label>Rescan</label>
                <action type=\"clear\">DECKLINK_INPUT_CHOICE</action>
                <action type=\"refresh\">DECKLINK_INPUT_CHOICE</action>
            </button>"
        elif [[ "${VARIABLE_NAME}" == "AVFCTL_INPUT_CHOICE" ]] ; then
            echo "
            <button>
                <label>Rescan</label>
                <action type=\"clear\">AVFCTL_INPUT_CHOICE</action>
                <action type=\"refresh\">AVFCTL_INPUT_CHOICE</action>
            </button>"
        fi
    }

    echo "<vbox>
      <text>
          <label>${LABEL}</label>
      </text>
      <list selection-mode=\"1\" selected-row=\"${SELECTION}\">
          <width>${WIDTH}</width>
          <variable>${VARIABLE_NAME}</variable>
          ${LIST}
          $(_get_list_extras)
      </list>
      $(_get_vbox_extras)
    </vbox>"
}

_setup_vrecord_process(){
    _set_ffmpeg_loglevel(){
        if [[ "$VERBOSE" = "true" ]] ; then
            GRAB_INPUT+=(-loglevel debug)
            _report -wt "When running vrecord in verbose mode, avoid using Visual + Numerical option."
        else
            GRAB_INPUT+=(-loglevel info)
        fi
    }
    # set up input and playback
    unset GRAB_INPUT
    if [[ -n "${ALT_INPUT}" ]] ; then
        GRAB_INPUT+=("${EXTRAINPUTOPTIONS[@]}")
        GRAB_INPUT+=(-i "${ALT_INPUT}")
    elif [[ "${DEVICE_INPUT_CHOICE}" = 0 ]] ; then
        if [[ "${DECKLINK_UTILITY_CHOICE}" == "bmdcapture" ]] ; then
            GRAB_INPUT+=(-A "${BMD_AUDIO_INPUT}")
            GRAB_INPUT+=(-V "${BMD_VIDEO_INPUT}")
            GRAB_INPUT+=(-m "${BMD_STANDARD}")
            GRAB_INPUT+=(-c 8)
            GRAB_INPUT+=(-s 32)
            GRAB_INPUT+=(-p "${BMD_PIXEL_FORMAT}")
            GRAB_INPUT+=(-F "matroska")
            GRAB_INPUT+=(-d "0")
            GRAB_INPUT+=(-f pipe:1)
        else
            _set_ffmpeg_loglevel
            GRAB_INPUT+=(-f decklink)
            GRAB_INPUT+=(-draw_bars 0)
            GRAB_INPUT+=(-audio_input "${AUDIO_INPUT}")
            GRAB_INPUT+=(-video_input "${VIDEO_INPUT}")
            GRAB_INPUT+=(-format_code "${STANDARD}")
            GRAB_INPUT+=(-channels 8)
            GRAB_INPUT+=(-audio_depth 32)
            GRAB_INPUT+=(-raw_format "${PIXEL_FORMAT}")
            GRAB_INPUT+=("${EXTRAINPUTOPTIONS[@]}")
            GRAB_INPUT+=(-i "${DECKLINK_INPUT_CHOICE}")
        fi
    elif [[ "${DEVICE_INPUT_CHOICE}" = 1 ]] ; then
        if [[ "${OS_TYPE}" = "linux" ]] ; then
            GRAB_INPUT+=(-f iec61883)
            GRAB_INPUT+=(-i auto)
        elif [[ "${OS_TYPE}" = "macOS" ]] ; then
            AVFCTL_INPUT_INDEX="$(echo "${AVFCTL_INPUT_CHOICE}" | cut -c 2)"
            GRAB_INPUT+=(-device "${AVFCTL_INPUT_INDEX}")
            GRAB_INPUT+=(-cmd capture)
            GRAB_INPUT+=(-)
        fi
        MIDDLEOPTIONS+=(-c copy -map 0)
    elif [[ "${DEVICE_INPUT_CHOICE}" = 2 ]] ; then
        _set_ffmpeg_loglevel
        #Mac Options
        #Linux Options
        if [[ "${OS_TYPE}" = "linux" ]] ; then
            _get_audio_dev_num
            GRAB_INPUT+=(-f alsa)
            GRAB_INPUT+=(-acodec pcm_s32le -ac 2)
            GRAB_INPUT+=(${S_RATE})
            GRAB_INPUT+=(-i hw:"${AUDIO_DEV_NUM}")
        elif [[ "${OS_TYPE}" = "macOS" ]] ; then
            GRAB_INPUT+=(-f avfoundation)
            GRAB_INPUT+=(-i "none:${AUDIO_DEV_CHOICE}")
        fi
    else
        _report "Input unknown"
        exit 1
    fi

    if [[ "${DEVICE_INPUT_CHOICE}" = 0 ]] ; then
        PIPE_OUTPUT=(-c copy)
        PIPE_OUTPUT+=(-c:a pcm_s24le)
        PIPE_OUTPUT+=(-map 0)
        PIPE_OUTPUT+=(-f matroska)
        PIPE_OUTPUT+=(-write_crc32 0)
        PIPE_OUTPUT+=(-live true)
        PIPE_OUTPUT+=(-)
        WINDOW_NAME="mode:${RUNTYPE} - video:'${VIDEO_INPUT}' audio:'${AUDIO_INPUT}' - to end recording press q, esc, or close video window"
    elif [[ "${DEVICE_INPUT_CHOICE}" = 1 ]] ; then
        PIPE_OUTPUT=(-c copy)
        PIPE_OUTPUT+=(-map 0)
        PIPE_OUTPUT+=(-f rawvideo)
        PIPE_OUTPUT+=(-)
        WINDOW_NAME="mode:${RUNTYPE} - input:'${AVFCTL_INPUT_CHOICE}' - to end recording press q, esc, or close video window"
    elif [[ "${DEVICE_INPUT_CHOICE}" = 2 ]] ; then
        PIPE_OUTPUT+=(-c:a pcm_s16le -ar 48k)
        PIPE_OUTPUT+=(-f wav)
        PIPE_OUTPUT+=(-)
        WINDOW_NAME="mode:${RUNTYPE} - input:'${AUDIO_DEV_CHOICE}' - to end recording press q, esc, or close video window"
    else
        _report "Input unknown"
        exit 1
    fi
    if [[ "${DEVICE_INPUT_CHOICE}" = 0 ]] ; then
        # DEVICE_INPUT_CHOICE=0 is decklink, other DEVICE_INPUT_CHOICE values don't yet use such filtering
        if [[ "${DECKLINK_UTILITY_CHOICE}" == "bmdcapture" ]] ; then
            if [[ "${RUNTYPE}" = "record" ]] ; then
                VRECORD_STEPS="3" # Steps: record | ff_record | player
            else
                VRECORD_STEPS="2" # Steps: record | player
            fi
            RECORD_COMMAND=("bmdcapture")
            # TO DO adjust TIME_LIMIT for bmdcapture
            RECORD_COMMAND+=("${GRAB_INPUT[@]}")
            FF_RECORD_COMMAND=("${FFMPEG_BIN}" -nostdin -nostats "${TIME_LIMIT[@]}")
            FF_RECORD_COMMAND+=(-i -)
            if [[ -n "${VIDEOCODECNAME}" ]] ; then
                MIDDLEOPTIONS+=(-metadata:s:v:0 encoder="${VIDEOCODECNAME}")
            fi
            FF_RECORD_COMMAND+=("${MIDDLEOPTIONS[@]}")
            if [[ "${PLAYBACKVIEW_CHOICE_PASS}" != "Audio + Video" ]] ; then
                FF_RECORD_COMMAND+=(-filter_complex "[0:v:0]${RECORDINGFILTER}${TC_WRITE}; ${AUDIOMAP}" "${AUDIO_CHANNEL_MAP[@]}")
                FF_RECORD_COMMAND+=(-f "${FORMAT}" "${VRECORD_OUTPUT}")
            fi
            FF_RECORD_COMMAND+=("${EXTRAOUTPUTS[@]}" "${PIPE_OUTPUT[@]}")
        else
            if [[ "${RUNTYPE}" = "record" ]] ; then
                VRECORD_STEPS="2" # Steps: record | player
            else
                VRECORD_STEPS="1" # Steps: player
            fi
            if [[ "${PLAYBACKVIEW_CHOICE_PASS}" = "Audio + Video" ]] ; then
                VRECORD_STEPS="$((VRECORD_STEPS+1))"
            fi
            RECORD_COMMAND=("${FFMPEG_BIN}")
            RECORD_COMMAND+=(-nostdin -nostats "${TIME_LIMIT[@]}" "${GRAB_INPUT[@]}")
            if [[ -n "${VIDEOCODECNAME}" ]] ; then
                MIDDLEOPTIONS+=(-metadata:s:v:0 encoder="${VIDEOCODECNAME}")
            fi
            RECORD_COMMAND+=("${MIDDLEOPTIONS[@]}")
            if [[ "${PLAYBACKVIEW_CHOICE_PASS}" != "Audio + Video" ]] ; then
                RECORD_COMMAND+=(-filter_complex "[0:v:0]${RECORDINGFILTER}${TC_WRITE}; ${AUDIOMAP}" "${AUDIO_CHANNEL_MAP[@]}")
                RECORD_COMMAND+=(-f "${FORMAT}" "${VRECORD_OUTPUT}")
            fi
            RECORD_COMMAND+=("${EXTRAOUTPUTS[@]}" "${PIPE_OUTPUT[@]}")
        fi
    elif [[ "${DEVICE_INPUT_CHOICE}" = 1 ]] ; then
        if [[ "${OS_TYPE}" = "linux" ]] ; then
            if [[ "${RUNTYPE}" = "record" ]] ; then
                VRECORD_STEPS="2" # Steps: record | player
            else
                VRECORD_STEPS="1" # Steps: player
            fi
            RECORD_COMMAND=("${FFMPEG_BIN}" -nostdin -nostats "${TIME_LIMIT[@]}" "${GRAB_INPUT[@]}")
            RECORD_COMMAND+=(-map 0:v -c copy)
            RECORD_COMMAND+=(-f "${FORMAT}" "${VRECORD_OUTPUT}")
            RECORD_COMMAND+=(-map 0:v -f rawvideo -c copy -)
        else
            if [[ "${RUNTYPE}" = "record" ]] ; then
                VRECORD_STEPS="3" # Steps: record | ff_record | player
            else
                VRECORD_STEPS="2" # Steps: record | player
            fi
            RECORD_COMMAND=(avfctl)
            RECORD_COMMAND+=("${GRAB_INPUT[@]}")
            FF_RECORD_COMMAND=("${FFMPEG_BIN}" -nostdin -nostats "${TIME_LIMIT[@]}")
            FF_RECORD_COMMAND+=(-i -)
            FF_RECORD_COMMAND+=(-map 0:v -c copy)
            FF_RECORD_COMMAND+=(-f "${FORMAT}" "${VRECORD_OUTPUT}")
            FF_RECORD_COMMAND+=(-map 0:v -f rawvideo -c copy -)
        fi
    elif [[ "${DEVICE_INPUT_CHOICE}" = 2 ]] ; then
        VRECORD_STEPS="2" # Steps: record | player (record is adjusted if actually recording)
        RECORD_COMMAND=("${FFMPEG_BIN}")
        RECORD_COMMAND+=(-nostdin -nostats "${TIME_LIMIT[@]}" "${GRAB_INPUT[@]}")
        RECORD_COMMAND+=("${MIDDLEOPTIONS[@]}")
        if [[ "${RUNTYPE}" = "record" ]] ; then
            RECORD_COMMAND+=(-f "${FORMAT}" -filter_complex "${AUDIOMAP}" "${AUDIO_CHANNEL_MAP[@]}" "${VRECORD_OUTPUT}")
        fi
        RECORD_COMMAND+=(-filter_complex "${AUDIOMAP}" "${AUDIO_CHANNEL_MAP[@]}" "${PIPE_OUTPUT[@]}")
    else
        _report_unexpected_error DEVICE_INPUT_CHOICE
    fi
    # get player command
    if [[ "${MEDIA_PLAYER_CHOICE}" = "mpv" ]] ; then
        _check_mpv
        MPVOPTS=(--no-osc)
        MPVOPTS+=(--load-scripts=no)
        MPVOPTS+=(--script="${RESOURCE_PATH}/qcview.lua")
        MPVOPTS+=(--really-quiet)
        MPVOPTS+=(--title="${WINDOW_NAME}")
        PLAYER_COMMAND=(mpv "${MPVOPTS[@]}" -)
    else
        FFPLAY_OPTIONS=(-v info)
        FFPLAY_OPTIONS+=(-hide_banner)
        FFPLAY_OPTIONS+=(-stats)
        FFPLAY_OPTIONS+=(-autoexit)
        FFPLAY_OPTIONS+=(-window_title "${WINDOW_NAME}")
        if [[ "${DEVICE_INPUT_CHOICE}" = 0 ]] && [[ "${PLAYBACKVIEW_CHOICE_PASS}" = "Audio + Video" ]] ; then
            FFPLAY_OPTIONS+=(-f lavfi "amovie='pipe\:0':${PLAYBACKFILTER}")
        elif [[ "${DEVICE_INPUT_CHOICE}" = 2 ]] ; then
            FFPLAY_OPTIONS+=(-f lavfi "amovie='pipe\:0',${PLAYBACKFILTER}")
        else
            if [[ "${VRECORD_STEPS}" = "1" ]] ; then
                FFPLAY_OPTIONS+=("${GRAB_INPUT[@]}")
            else
                FFPLAY_OPTIONS+=(-i -)
            fi
            if [[ -n "${PLAYBACKFILTER}" ]] ; then
                FFPLAY_OPTIONS+=(-vf "${PLAYBACKFILTER}")
            fi
            FFPLAY_OPTIONS+=(-af "channelmap=0|1:stereo")
        fi
        PLAYER_COMMAND=("${FFPLAY_BIN}" "${FFPLAY_OPTIONS[@]}")
    fi
}

_get_decklink_inputs(){
    # get information on what input device options are available
    unset DECKLINK_DEVICES
    while read decklink_device ; do
        DECKLINK_DEVICES+=("${decklink_device}")
    done < <("${FFMPEG_BIN}" -nostdin -v 0 -sources decklink | awk -F'[][]' '{print $2}' | grep -v "^$")
    if [[ "${#DECKLINK_DEVICES[@]}" = 1 ]] ; then # default to first input if only one
        DECKLINK_INPUT_CHOICE="${DECKLINK_DEVICES[0]}"
    fi
}
_get_avfoundation_inputs(){
    # set avfoundation input options
    unset AVFOUNDATION_DEVICES
    while read avf_device ; do
        AVFOUNDATION_DEVICES+=("${avf_device}")
    done < <("${FFMPEG_BIN}" -nostdin -hide_banner -f avfoundation -list_devices 1 -i dummy 2>&1 | grep -A 10 "AVFoundation audio devices" | grep -o "\[[0-9]\].*" | cut -d " " -f2-)
}

_get_avfctl_inputs(){
    # set avfctl input options
    unset AVFCTL_DEVICES
    while read avfctl_device ; do
        AVFCTL_DEVICES+=("${avfctl_device}")
    done < <(avfctl -list_devices 2>&1 | grep -A 10 "Devices:" | grep -o "\[[0-9]\].*")
    if [[ "${#AVFCTL_DEVICES[@]}" = 1 ]] ; then # default to first input if only one
        AVFCTL_INPUT_CHOICE="${AVFCTL_DEVICES[0]}"
    fi
    if [[ "${OS_TYPE}" = "linux" ]] ; then
        AVFCTL_DEVICES+=('Default DV Device')
    fi
}

_get_decklink_inputs
_get_avfoundation_inputs
_get_avfctl_inputs

if [[ "${OS_TYPE}" = "linux" ]] ; then
    while read audio_device ; do
        AUDIO_DEVICES+=("${audio_device}")
    done < <(arecord -l | grep card | cut -d ':' -f2 | cut -d ',' -f1 | awk '{$1=$1;print}')
elif [[ "${OS_TYPE}" = "macOS" ]] ; then
    AUDIO_DEVICES=("${AVFOUNDATION_DEVICES[@]}")
fi

_get_audio_dev_num(){
    AUDIO_DEV_NUM=0
    while [[ "${AUDIO_DEV_CHOICE}" != "${AUDIO_DEVICES[${AUDIO_DEV_NUM}]}" ]] ; do
        AUDIO_DEV_NUM=$(( ${AUDIO_DEV_NUM} + 1 ))
    done
}

_set_up_edit_form() {
  _expand_list2items(){
    LIST=( "$@" )
    for i in "${LIST[@]}" ; do
      if [[ "$i" == "Quality Control View (mpv)" ]] && ! $MPV_INSTALLED ; then
          :
      elif [[ "$i" == "bmdcapture" ]] && ! $BMDTOOLS_INSTALLED ; then
          :
      else
          echo "<item>${i}</item>"
      fi
    done
  }
  _get_index_of_value(){
    # run with function, value to look for as first argument, and array to look in as 2nd argument, such function as
    # _get_index_of_value "${VIDEO_INPUT_CHOICE}" "${VIDEO_INPUT_OPTIONS[@]}"
    VALUE="${1}"
    shift
    LIST=( "$@" )
    INDEX=0
    MATCH=""
    for ITEM in "${LIST[@]}" ; do
        if [[ "${VALUE}" = "${ITEM}" ]] ; then
            MATCH="$INDEX"
        fi
        (( ++INDEX ))
    done
    if [[ -n "${MATCH}" ]] ; then
        echo -n "${MATCH}"
    fi
  }

# initialize deckcontrol temp files
FFMPEG_STATUS_TMP="$(_maketemp .ffmpeg.status.txt)"
DECKCONTROL_STATUS_TMP="$(_maketemp .deckcontrol.status.txt)"
DECKCONTROL_TIMECODE_TMP="$(_maketemp .deckcontrol.timecode.txt)"
AVFCTL_STATUS_TMP="$(_maketemp .avfctl.status.txt)"
echo "" > "${FFMPEG_STATUS_TMP}"
echo "disabled" > "$DECKCONTROL_STATUS_TMP"
echo "--:--:--:--" > "$DECKCONTROL_TIMECODE_TMP"
echo "disabled" > "$AVFCTL_STATUS_TMP"

SIDECAR_FILES_GUI="
<frame Sidecar file options>
    <hbox space-expand=\"true\">
        $(_gtk_vbox_list "FRAMEMD5_CHOICE"   "100"  "frameMD5s? (recommended)"  "${FRAMEMD5_OPTIONS[@]}")
        $(_gtk_vbox_list "QCTOOLSXML_CHOICE" "200"  "QCTools XML?"              "${QCTOOLSXML_OPTIONS[@]}")
    </hbox>
</frame>"

PLAYBACK_OPT_GUI="
<frame Playback options>
    <hbox space-expand=\"true\">
        $(_gtk_vbox_list "PLAYBACKVIEW_CHOICE"      "200" "Select View (for recording)"   "${PLAYBACKVIEW_OPTIONS[@]}")
        $(_gtk_vbox_list "PLAYBACKVIEW_CHOICE_PASS" "200" "Select View (for passthrough)" "${PLAYBACKVIEW_PASS_OPTIONS[@]}")
    </hbox>
</frame>"

OPTIONAL_TOOLS_GUI=$(cat << CONFIG_FORM
<frame Optional Tools>
  <hbox>
        <text>
            <label>bmdtools: </label>
        </text>
        <pixmap stock-icon-size="1" tooltip-text="If bmdtools is installed, vrecord can offer bmdcapture as an alternate method (to ffmpeg) to receive an input from a Blackmagic capture device.">
            <input file stock="$(if $BMDTOOLS_INSTALLED ; then echo gtk-yes ; else echo gtk-no ; fi)"></input>
        </pixmap>
    </hbox>
    <hbox>
        <text>
            <label>deckcontrol: </label>
        </text>
        <pixmap stock-icon-size="1" tooltip-text="If deckcontrol is installed, vrecord can offer an interface to control videodecks via RS422 via a Blackmagic capture device.">
            <input file stock="$(if $DECKCONTROL_INSTALLED ; then echo gtk-yes ; else echo gtk-no ; fi)"></input>
        </pixmap>
    </hbox>
    <hbox>
        <text>
            <label>gnuplot: </label>
        </text>
        <pixmap stock-icon-size="1" tooltip-text="If gnuplot is installed, vrecord can may a graph output from qctools reports.">
            <input file stock="$(if $GNUPLOT_INSTALLED ; then echo gtk-yes ; else echo gtk-no ; fi)"></input>
        </pixmap>
    </hbox>
    <hbox>
        <text>
            <label>mediaconch: </label>
        </text>
        <pixmap stock-icon-size="1" tooltip-text="If mediaconch is installed, vrecord can perform checks after capture to ensure the file is as expected.">
            <input file stock="$(if $MEDIACONCH_INSTALLED ; then echo gtk-yes ; else echo gtk-no ; fi)"></input>
        </pixmap>
    </hbox>
    <hbox>
        <text>
            <label>mkvpropedit: </label>
        </text>
        <pixmap stock-icon-size="1" tooltip-text="If mkvpropedit is installed, vrecord can embed capture logs into any Matroska recordings.">
            <input file stock="$(if $MKVPROPEDIT_INSTALLED ; then echo gtk-yes ; else echo gtk-no ; fi)"></input>
        </pixmap>
    </hbox>
    <hbox>
        <text>
            <label>mpv: </label>
        </text>
        <pixmap stock-icon-size="1" tooltip-text="If mpv is installed, vrecord can offer additional playback view options.">
            <input file stock="$(if $MPV_INSTALLED ; then echo gtk-yes ; else echo gtk-no ; fi)"></input>
        </pixmap>
    </hbox>
    <hbox>
        <text>
            <label>qcli: </label>
        </text>
        <pixmap stock-icon-size="1" tooltip-text="If qcli is installed, vrecord can offer options to create QCTools reports during or after capture.">
            <input file stock="$(if $QCLI_INSTALLED ; then echo gtk-yes ; else echo gtk-no ; fi)"></input>
        </pixmap>
    </hbox>
    <hbox space-fill="true" space-expand="true">
        <vbox>
            <text>
                <label>FFmpeg Status</label>
            </text>
            <vbox scrollable="true" height="240">
                <text wrap="true" xalign="0" selectable="true">
                    <variable export="false">ffmpeg_status</variable>
                    <input file>"${FFMPEG_STATUS_TMP}"</input>
                </text>
            </vbox>
            <button>
                <label>Check FFmpeg status</label>
                <action>_check_ffmpeg_install > ${FFMPEG_STATUS_TMP}</action>
                <action type="refresh">ffmpeg_status</action>
            </button>
        </vbox>
        <vbox>
            <text>
                <label>Environment</label>
            </text>
            <vbox scrollable="true" height="240">
                <text xalign="0" selectable="true">
                    <variable export="false">vrecord_env</variable>
                    <input file>"${VRECORD_VARS_FILE}"</input>
                </text>
            </vbox>
        </vbox>
    </hbox>
</frame>
CONFIG_FORM
)

DECKLINK_INPUT_GUI=$(cat << DECKLINK_FORM
<frame Decklink input options>
    <vbox>
        <hbox space-expand="true">
            $(_gtk_vbox_list "DECKLINK_UTILITY_CHOICE"  "100" "Select Input Utility"          "${DECKLINK_UTILITIES[@]}")
            $(_gtk_vbox_list "DECKLINK_INPUT_CHOICE"    "160" "Select Video Card"             "${DECKLINK_DEVICES[@]}")
            $(_gtk_vbox_list "VIDEO_INPUT_CHOICE"       "100" "Select Video Input"            "${VIDEO_INPUT_OPTIONS[@]}")
            $(_gtk_vbox_list "AUDIO_INPUT_CHOICE"       "200" "Select Audio Input"            "${AUDIO_INPUT_OPTIONS[@]}")
            $(_gtk_vbox_list "AUDIO_MAPPING_CHOICE"     "300" "Select Audio Channel Mapping"  "${CHANNEL_MAPPING_OPTIONS[@]}" )
            $(_gtk_vbox_list "STANDARD_CHOICE"          "100" "Select Standard"               "${STANDARD_OPTIONS[@]}")
            $(_gtk_vbox_list "VIDEO_BIT_DEPTH_CHOICE"   "100" "Select Video Bit Depth"        "${VIDEO_BITDEPTH_OPTIONS[@]}")
            $(_gtk_vbox_list "TIMECODE_CHOICE"          "100" "Select timecode format"        "${TIMECODE_OPTIONS[@]}")
        </hbox>
        <checkbox>
            <label>Invert Second Channel of Audio (WARNING: Do not use this option unless required)</label>
            <default>false</default>
            <variable>INVERT_PHASE</variable>
        </checkbox>
        <frame Output file options>
            <hbox space-expand="true">
                $(_gtk_vbox_list "EMBED_LOGS_CHOICE"        "100" "Embed digitization logs in video file (Matroska ONLY)" "${EMBED_LOGS_OPTIONS[@]}")
                $(_gtk_vbox_list "CONTAINER_CHOICE"         "100" "Select File Format"            "${CONTAINER_OPTIONS[@]}")
                $(_gtk_vbox_list "FFV1_SLICE_CHOICE"        "100" "FFV1 Slice Count"              "${FFV1_SLICE_OPTIONS[@]}")
                $(_gtk_vbox_list "VIDEO_CODEC_CHOICE"       "160" "Select Video Codec"            "${VIDEO_CODEC_OPTIONS[@]}")
                $(_gtk_vbox_list "AUDIO_CODEC_CHOICE"       "100" "Select Audio Codec"            "${AUDIO_CODEC_OPTIONS[@]}")
            </hbox>
        </frame>
        <hbox>
            ${PLAYBACK_OPT_GUI}
            ${SIDECAR_FILES_GUI}
            <frame RS422 deck control>
                <hbox>
                    <vbox>
                        <text>
                            <label>Status</label>
                        </text>
                        <entry editable="false" has-frame="false">
                            <variable export="false">decklink_status</variable>
                            <input file>"${DECKCONTROL_STATUS_TMP}"</input>
                        </entry>
                    </vbox>
                    <vbox>
                        <text>
                            <label>Timecode</label>
                        </text>
                        <entry editable="false" has-frame="false">
                            <variable export="false">decklink_timecode</variable>
                            <input file>"${DECKCONTROL_TIMECODE_TMP}"</input>
                        </entry>
                    </vbox>
                    <timer milliseconds="true" interval="500" visible="false" disabled="true">
                         <variable export="false">deckcontrol_timer</variable>
                         <visible>disabled</visible>
                         <action>{ deckcontrol getcurrentstate | grep "state:\|detect" | sed "s/VTR control state: //g" > "${DECKCONTROL_STATUS_TMP}" ; deckcontrol gettimecode | grep "TC=" | cut -c 4- > "${DECKCONTROL_TIMECODE_TMP}" ; } &</action>
                         <action>refresh:decklink_status</action>
                         <action>refresh:decklink_timecode</action>
                    </timer>
                </hbox>
                <hbox>
                    <togglebutton>
                        <label>Deck Control</label>
                        <default>false</default>
                        <variable export="false">deckcontrol_toggle</variable>
                        <input file stock="gtk-execute"></input>
                        <action>if true enable:deckcontrol_timer</action>
                        <action>if true enable:decklink_status</action>
                        <action>if true enable:decklink_timecode</action>
                        <action>if true enable:deckcontrol_rewind</action>
                        <action>if true enable:deckcontrol_prev</action>
                        <action>if true enable:deckcontrol_play</action>
                        <action>if true enable:deckcontrol_stop</action>
                        <action>if true enable:deckcontrol_next</action>
                        <action>if true enable:deckcontrol_ff</action>
                        <action>if true enable:deckcontrol_eject</action>
                        <action>if false disable:deckcontrol_timer</action>
                        <action>if false disable:decklink_status</action>
                        <action>if false disable:decklink_timecode</action>
                        <action>if false disable:deckcontrol_rewind</action>
                        <action>if false disable:deckcontrol_prev</action>
                        <action>if false disable:deckcontrol_play</action>
                        <action>if false disable:deckcontrol_stop</action>
                        <action>if false disable:deckcontrol_next</action>
                        <action>if false disable:deckcontrol_ff</action>
                        <action>if false disable:deckcontrol_eject</action>
                    </togglebutton>
                    <hbox>
                        <button>
                            <variable export="false">deckcontrol_rewind</variable>
                            <input file stock="gtk-media-rewind"></input>
                            <visible>disabled</visible>
                            <action>deckcontrol rewind & >/dev/null</action>
                        </button>
                        <button>
                            <variable export="false">deckcontrol_prev</variable>
                            <input file stock="gtk-media-previous"></input>
                            <visible>disabled</visible>
                            <action>deckcontrol stepback & >/dev/null</action>
                        </button>
                        <button>
                            <variable export="false">deckcontrol_play</variable>
                            <input file stock="gtk-media-play"></input>
                            <visible>disabled</visible>
                            <action>deckcontrol play & >/dev/null</action>
                        </button>
                        <button>
                            <variable export="false">deckcontrol_stop</variable>
                            <input file stock="gtk-media-stop"></input>
                            <visible>disabled</visible>
                            <action>deckcontrol stop & >/dev/null</action>
                        </button>
                        <button>
                            <variable export="false">deckcontrol_next</variable>
                            <input file stock="gtk-media-next"></input>
                            <visible>disabled</visible>
                            <action>deckcontrol stepforward & >/dev/null</action>
                        </button>
                        <button>
                            <variable export="false">deckcontrol_ff</variable>
                            <input file stock="gtk-media-forward"></input>
                            <visible>disabled</visible>
                            <action>deckcontrol fastforward & >/dev/null</action>
                        </button>
                        <button>
                            <variable export="false">deckcontrol_eject</variable>
                            <label>Eject</label>
                            <visible>disabled</visible>
                            <action>deckcontrol eject & >/dev/null</action>
                        </button>
                    </hbox>
                </hbox>
            </frame>
        </hbox>
    </vbox>
</frame>
DECKLINK_FORM
)

# Set DV Control variables
if [[ "${OS_TYPE}" = "linux" ]] ; then
        DV_REPACK_CMD=""
        DV_RW_CMD='dvcont rewind '
        DV_PLAY_CMD='dvcont play '
        DV_STOP_CMD='dvcont stop '
        DV_FF_CMD='dvcont ff '
        STATUS_CMD='dvcont status '
    elif [[ "${OS_TYPE}" = "macOS" ]] ; then
        DV_REPACK_CMD='{ avfctl -cmd ff -foreground; avfctl -cmd rew; }'
        DV_RW_CMD='avfctl -cmd rew '
        DV_PLAY_CMD='avfctl -cmd play '
        DV_STOP_CMD='avfctl -cmd stop '
        DV_FF_CMD='avfctl -cmd ff '
        STATUS_CMD="avfctl -status 2>&1 | grep -o 'Device \[.*' | sed 's|Device ||g;s| status||g'"
fi

AVFCTL_INPUT_GUI=$(cat << AVFCTL_FORM
<frame DVRescue avfctl input options>
    <vbox>
        <hbox space-expand="true">
            $(_gtk_vbox_list "AVFCTL_INPUT_CHOICE"         "-1" "Select a DV Device"           "${AVFCTL_DEVICES[@]}")
        </hbox>
    </vbox>
    <frame DV deck control>
        <hbox>
            <vbox>
                <text>
                    <label>Status</label>
                </text>
                <entry editable="false" has-frame="false">
                    <variable export="false">avfctl_status</variable>
                    <input file>"${AVFCTL_STATUS_TMP}"</input>
                </entry>
            </vbox>
            <timer milliseconds="true" interval="300" visible="false" disabled="true">
                 <variable export="false">avfctl_timer</variable>
                 <visible>disabled</visible>
                 <action>${STATUS_CMD} > "${AVFCTL_STATUS_TMP}" &</action>
                 <action>refresh:avfctl_status</action>
            </timer>
        </hbox>
        <hbox>
            <togglebutton>
                <label>Deck Control</label>
                <default>false</default>
                <variable export="false">avfctl_toggle</variable>
                <input file stock="gtk-execute"></input>
                <action>if true enable:avfctl_timer</action>
                <action>if true enable:avfctl_status</action>
                <action>if true enable:avfctl_repack</action>
                <action>if true enable:avfctl_rewind</action>
                <action>if true enable:avfctl_play</action>
                <action>if true enable:avfctl_stop</action>
                <action>if true enable:avfctl_ff</action>
                <action>if false disable:avfctl_timer</action>
                <action>if false disable:avfctl_status</action>
                <action>if false disable:avfctl_repack</action>
                <action>if false disable:avfctl_rewind</action>
                <action>if false disable:avfctl_play</action>
                <action>if false disable:avfctl_stop</action>
                <action>if false disable:avfctl_ff</action>
            </togglebutton>
            <hbox>
                <button>
                    <variable export="false">avfctl_repack</variable>
                    <label>Repack</label>
                    <visible>disabled</visible>
                    <action>${DV_REPACK_CMD}&</action>
                </button>
                <button>
                    <variable export="false">avfctl_rewind</variable>
                    <input file stock="gtk-media-rewind"></input>
                    <visible>disabled</visible>
                    <action>${DV_RW_CMD}&</action>
                </button>
                <button>
                    <variable export="false">avfctl_play</variable>
                    <input file stock="gtk-media-play"></input>
                    <visible>disabled</visible>
                    <action>${DV_PLAY_CMD}&</action>
                </button>
                <button>
                    <variable export="false">avfctl_stop</variable>
                    <input file stock="gtk-media-stop"></input>
                    <visible>disabled</visible>
                    <action>${DV_STOP_CMD}&</action>
                </button>
                <button>
                    <variable export="false">avfctl_ff</variable>
                    <input file stock="gtk-media-forward"></input>
                    <visible>disabled</visible>
                    <action>${DV_FF_CMD}&</action>
                </button>
            </hbox>
        </hbox>
        <vbox space-expand="true">
            <pixmap><input file>"${RESOURCE_PATH}/dvrecord.png"</input></pixmap>
        </vbox>
    </frame>
</frame>
AVFCTL_FORM
)

AUDIO_INPUT_GUI='
<frame Audio input options>
  <vbox space-expand="true">
    <hbox space-expand="true">
      '$(_gtk_vbox_list "AUDIO_DEV_CHOICE"         "-1" "Select an Audio Device"           "${AUDIO_DEVICES[@]}")'
      '$(_gtk_vbox_list "AUDIO_MODE_CODEC_CHOICE"  "-1" "Select Audio Codec"            "${AUDIO_CODEC_OPTIONS[@]:0:2}")'
      '$(_gtk_vbox_list "AUDIO_CHANNEL_CHOICE"     "-1" "Select Audio Channels"            "${AUDIO_CHANNEL_CHOICE_OPTIONS[@]}")'
      '$(_gtk_vbox_list "AUDIO_MODE_SR_CHOICE"     "-1" "Select Sampling Rate"            "${AUDIO_MODE_SR_CHOICE_OPTIONS[@]}")'
    </hbox>
  </vbox>
  <vbox space-expand="true">
    <pixmap><input file>'"${RESOURCE_PATH}/audio_mode.gif"'</input></pixmap>
  </vbox>
</frame>'

export MAIN_DIALOG='
<window title="vrecord configuration">
    <vbox>
        <text>
            <label>Set file recording options.</label>
        </text>
        <frame Input Options>
        <notebook page="'"${DEVICE_INPUT_CHOICE}"'" tab-labels="Decklink|DV|Audio|Config">
            '"${DECKLINK_INPUT_GUI}"'
            '"${AVFCTL_INPUT_GUI}"'
            '"${AUDIO_INPUT_GUI}"'
            '"${OPTIONAL_TOOLS_GUI}"'
            <variable>DEVICE_INPUT_CHOICE</variable>
            <action signal="button-release-event" type="refresh">VRECORD_OUTPUT_NAME</action>
        </notebook>
        </frame>
        <hbox>
            <frame Select a recording directory>
                <hbox>
                    <entry accept="directory" fs-title="'"${DIR_SELECTION_DIALOG}"'">
                        <variable>DIR</variable>
                        <default>'"${DIR:-\"\"}"'</default>
                        <action signal="key-release-event" type="refresh">VRECORD_OUTPUT_NAME</action>
                    </entry>
                    <button>
                        <input file stock="gtk-open"></input>
                        <variable>DIRBROWSE</variable>
                        <action type="fileselect">DIR</action>
                    </button>
                </hbox>
            </frame>
            <frame Select a directory for auxiliary files (leave blank to match the recording directory).>
                <hbox>
                    <entry accept="directory" tooltip-text="select the directory for automatically generated logs and checksums"  \fs-title="'"${DIR_SELECTION_DIALOG}"'">
                        <variable>LOGDIR</variable>
                        <default>'"${LOGDIR:-\"\"}"'</default>
                    </entry>
                    <button>
                        <input file stock="gtk-open"></input>
                        <variable>LOGDIRBROWSE</variable>
                        <action type="fileselect">LOGDIR</action>
                    </button>
                </hbox>
            </frame>
        </hbox>
        <hbox>
            <frame Recording event options>
                <hbox space-expand="true">
                    <vbox>
                        <text>
                            <label>Name of Recording</label>
                        </text>
                        <entry>
                            <default>"'"${ID}"'"</default>
                            <variable>ID</variable>
                            <action signal="key-release-event" type="refresh">VRECORD_OUTPUT_NAME</action>
                        </entry>
                    </vbox>
                    <vbox>
                        <text>
                            <label>Enter the name of the person digitizing this tape.</label>
                        </text>
                        <entry>
                            <variable>TECHNICIAN</variable>
                        </entry>
                    </vbox>
                    <vbox>
                        <text>
                            <label>Set recording time (integer or decimal) in minutes</label>
                        </text>
                        <entry activates_default="true" tooltip-text="Suggested:23 33 63 93. Leave blank for indefinite recording time">
                            <default>"'"${DURATION}"'"</default>
                            <variable>DURATION</variable>
                        </entry>
                    </vbox>
                </hbox>
            </frame>
            <frame File naming options>
                <hbox space-expand="true">
                    <vbox>
                        <text>
                            <label>Enter an optional file prefix</label>
                        </text>
                        <entry>
                            <default>"'"${PREFIX}"'"</default>
                            <variable>PREFIX</variable>
                            <action signal="key-release-event" type="refresh">VRECORD_OUTPUT_NAME</action>
                        </entry>
                    </vbox>
                    <vbox>
                        <text>
                            <label>Enter an optional file suffix</label>
                        </text>
                        <entry>
                            <default>"'"${USER_SUFFIX}"'"</default>
                            <variable>USER_SUFFIX</variable>
                            <action signal="key-release-event" type="refresh">VRECORD_OUTPUT_NAME</action>
                        </entry>
                    </vbox>
                    <vbox>
                        <checkbox>
                            <label>Check this to turn off appending of suffixes</label>
                            <default>"'"${NO_SUFFIX}"'"</default>
                            <variable>NO_SUFFIX</variable>
                            <action signal="key-release-event" type="refresh">VRECORD_OUTPUT_NAME</action>
                        </checkbox>
                    </vbox>
                </hbox>
            </frame>
        </hbox>
        <vbox>
            <hbox>
                <text>
                    <label>Output Filename:</label>
                </text>
                <entry editable="false" has-frame="false">
                    <variable>VRECORD_OUTPUT_NAME</variable>
                    <input>_get_output_filename</input>
                </entry>
            </hbox>
            <hbox>
                <text>
                    <label>Errors & Warnings:</label>
                </text>
                <vbox scrollable="true" height="28">
                    <text wrap="false" xalign="0" selectable="true">
                        <variable export="false">VRECORD_FORM_VALIDATION</variable>
                        <input>_validate_form</input>
                    </text>
                </vbox>
            </hbox>
        </vbox>
        <vbox>
            <hbox>
                <button>
                    <label>Record</label>
                    <input file stock="gtk-media-record"></input>
                    <variable>record_button</variable>
                    <action>_update_config_file</action>
                    <action type="exit">Record</action>
                </button>
                <button>
                    <label>Passthrough</label>
                    <input file stock="gtk-media-play"></input>
                    <variable>passthrough_button</variable>
                    <action>_update_config_file</action>
                    <action type="exit">passthrough</action>
                </button>
                <button>
                    <label>Save Settings</label>
                    <input file stock="gtk-save"></input>
                    <variable>save_button</variable>
                    <action>_update_config_file</action>
                </button>
                <button>
                    <label>Home</label>
                    <input file stock="gtk-index"></input>
                    <variable>home_button</variable>
                    <action>_update_config_file</action>
                    <action type="launch">HOME_DIALOG</action>
                </button>
                <button cancel>
                </button>
                <button>
                    <label>Refresh</label>
                    <input file stock="gtk-refresh"></input>
                    <action>_update_config_file</action>
                    <action type="exit">refresh</action>
                </button>
            </hbox>
        </vbox>
    </vbox>
    <variable>MAIN_DIALOG</variable>
    <action signal="show" type="refresh">VRECORD_FORM_VALIDATION</action>
    <action signal="enter-notify-event" type="refresh">VRECORD_FORM_VALIDATION</action>
    <action signal="leave-notify-event" type="refresh">VRECORD_FORM_VALIDATION</action>
    <action signal="show" type="closewindow">HOME_DIALOG</action>
    <action signal="show" type="refresh">VRECORD_OUTPUT_NAME</action>
</window>
'
}

HOME_DIALOG=$(cat << GTKFORM
<window title="Welcome to Vrecord!">
    <vbox>
        <vbox>
            <hbox>
                <button>
                    <label>Record</label>
                    <input file>${RESOURCE_PATH}/vrecord_logo.png</input>
                    <action type="exit">record</action>
                </button>
                <button>
                    <label>Passthrough</label>
                    <input file>${RESOURCE_PATH}/vrecord_logo_playback.png</input>
                    <action type="exit">passthrough</action>
                </button>
                <button>
                    <label>Audio Check</label>
                    <input file>${RESOURCE_PATH}/vrecord_logo_audio.png</input>
                    <action type="exit">audiopassthrough</action>
                </button>
                </hbox>
                <hbox>
                <button>
                    <label>Edit Settings</label>
                    <input file>${RESOURCE_PATH}/vrecord_logo_edit.png</input>
                    <action type="launch">MAIN_DIALOG</action>
                </button>
                <button>
                    <label>Help</label>
                    <input file>${RESOURCE_PATH}/vrecord_logo_help.png</input>
                    <action>man vrecord</action>
                </button>
                <button>
                    <label>Documentation</label>
                    <input file>${RESOURCE_PATH}/vrecord_logo_documentation.png</input>
                    <action>${OPEN_COMMAND} https://github.com/amiaopensource/vrecord#vrecord-documentation</action>
                </button>
            </hbox>
        </vbox>
        <hbox>
            <button cancel></button>
        </hbox>
    </vbox>
    <variable>HOME_DIALOG</variable>
    <action signal="show" type="closewindow">MAIN_DIALOG</action>
</window>
GTKFORM
)
export HOME_DIALOG


_report_var(){
    while [[ "${@}" != "" ]] ; do
        VAR_NAME="${1}"
        VAR_VALUE="${!1}"
        shift
        if   [[ "$VAR_NAME" == "DECKLINK_INPUT_CHOICE" ]] && [[ "${DEVICE_INPUT_CHOICE}" != "0" ]] ; then
            :
        elif [[ "$VAR_NAME" == "AVFCTL_INPUT_CHOICE" ]] && [[ "${DEVICE_INPUT_CHOICE}" != "1" ]] ; then
            :
        elif [[ "$VAR_NAME" == "FFV1_SLICE_CHOICE" ]] && [[ "${VIDEO_CODEC_CHOICE}" != "FFV1 version 3" ]] ; then
            :
        elif [[ "$VAR_NAME" == "EMBED_LOGS_CHOICE" ]] && [[ "${CONTAINER_CHOICE}" != "Matroska" ]] ; then
            :
        else
            printf " %-24s = %s \n" "$VAR_NAME" "$VAR_VALUE"
        fi
    done
}

# edit mode
_edit_mode(){

    _get_decklink_inputs
    _get_avfoundation_inputs
    _set_up_edit_form

    # run the edit form in gtkdialog
    HOME_DIALOG_TMP="${HOME_DIALOG}"
    MAIN_DIALOG_TMP="${MAIN_DIALOG}"

    GTK_INC="$(_maketemp .vrecord.gtkdialog.inc)"
    cat "${VRECORD_VARS_FILE}" > "${GTK_INC}"
    echo "CONFIG_FILE=${CONFIG_FILE}" >> "${GTK_INC}"
    cat "${SHARED_FUNCTIONS_FILE}" >> "${GTK_INC}"

    if [[ "${VERBOSE_GTKDIALOG}" = "Y" ]] ; then
        if [[ "$RUNTYPE" = "GUI" ]] || [[ "${GUI}" = "1" ]] ; then
            eval "$(gtkdialog --include="${GTK_INC}" --program HOME_DIALOG --center)"
        else
            eval "$(gtkdialog --include="${GTK_INC}" --program MAIN_DIALOG --center)"
        fi
    else
        if [[ "$RUNTYPE" = "GUI" ]] || [[ "${GUI}" = "1" ]] ; then
            eval "$(gtkdialog --include="${GTK_INC}" --program HOME_DIALOG --center 2> /dev/null)"
        else
            eval "$(gtkdialog --include="${GTK_INC}" --program MAIN_DIALOG --center 2> /dev/null)"
        fi
    fi
    HOME_DIALOG="${HOME_DIALOG_TMP}"
    MAIN_DIALOG="${MAIN_DIALOG_TMP}"

    # process the results of the edit form
    if   [[ "${EXIT}" = "abort" ]] ; then
        _report -d "Exiting Vrecord. Goodbye!"
        exit 0
    elif [[ "${EXIT}" = "Cancel" ]] ; then
        _report -d "Editing of preferences was canceled by the user."
        _report -d "Exiting Vrecord. Goodbye!"
        exit 0
    elif [[ "${EXIT}" = "Record" ]] ; then
        RUNTYPE="record"
    elif [[ "${EXIT}" = "passthrough" ]] ; then
        RUNTYPE="passthrough"
    elif [[ "${EXIT}" = "refresh" ]] ; then
        RUNTYPE="edit"
    elif [[ "${EXIT}" = "timecode_scan" ]] ; then
        _report -dt "Scanning each supported type of timecode."
        for timecode_type in "${TIMECODE_OPTIONS[@]}" ; do
            tc_value="$("${FFPROBE_BIN}" "${GRAB_INPUT[@]}" -timecode_format "${timecode_type}" -show_entries stream_tags=timecode -of default=nw=1:nk=1 2>/dev/null)"
            if [[ -z "${tc_value}" ]] ; then
                tc_value="none"
            fi
            echo "${timecode_type}: ${tc_value}"
        done
        RUNTYPE="edit"
    else
        _report_unexpected_error EXIT
    fi
}

# passthrough and audiopassthrough modes
_passthrough_mode(){
    _setup_vrecord_process
    if [[ "${VERBOSE_GTKDIALOG}" = "Y" ]] ; then
        echo "STEPS ${VRECORD_STEPS}"
        echo "PLAY ${PLAYER_COMMAND[@]}"
        echo "RECORD ${RECORD_COMMAND[@]}"
    fi
    if [[ "${VRECORD_STEPS}" = "1" ]] ; then
        "${PLAYER_COMMAND[@]}" 2> "${VRECORD_INPUT_TMP}"
    elif [[ "${VRECORD_STEPS}" = "2" ]] ; then
        "${RECORD_COMMAND[@]}" 2> "${VRECORD_INPUT_TMP}" | "${PLAYER_COMMAND[@]}"
    fi
}

_audiopassthrough_mode(){
    PLAYBACKVIEW_CHOICE_PASS="Audio + Video"
    _lookup_choice "Audio + Video"
    _passthrough_mode
}

# create a capture log of decisions made in vrecord
_writeingestlog(){
    if [[ "${INGESTLOG}" ]] ; then
        KEY="${1}"
        shift
        VALUE="${@}"
        # need to add yaml style escaping
        echo "${KEY}: ${VALUE}" >> "${INGESTLOG}"
    else
        _report -wt "The _writeingestlog function was called, but the ingestlog file (${INGESTLOG}) is not declared."
    fi
}

# create a jpeg of qc data graphs for quick assessment
_qcgraphimage(){
    # get audio data
    qctools_CONFIGFILE_A="$(_maketemp .astats_A.csv)"
    "${ZCAT_COMMAND}" "$1" | perl -nle 'print if not m{lavfi.(?!astats.Overall.Min_level|astats.Overall.Max_level|astats.Overall.Peak_level|aphasemeter.phase)}' | xmlstarlet select -t -m "//ffprobe:ffprobe/frames/frame[@media_type='audio']" \
       -v "@pkt_pts_time" -o " " \
       -v "tag[@key='lavfi.astats.Overall.Max_level']/@value" -o " " \
       -v "tag[@key='lavfi.astats.Overall.Min_level']/@value" -o " " \
       -v "tag[@key='lavfi.astats.Overall.Peak_level']/@value" -o " " \
       -v "tag[@key='lavfi.aphasemeter.phase']/@value" -n > "${qctools_CONFIGFILE_A}"
    # get video data
    qctools_CONFIGFILE_V="$(_maketemp .signalstats.V.csv)"
    "${ZCAT_COMMAND}" "$1" | perl -nle 'print if not m{lavfi.(?!signalstats.BRNG|signalstats.TOUT|signalstats.SATMAX|signalstats.SATAVG|ssim.Y|ssim.U|ssim.V)}' | xmlstarlet select -t -m "//ffprobe:ffprobe/frames/frame[@media_type='video']" \
       -v "@pkt_pts_time" -o " " \
       -v "tag[@key='lavfi.signalstats.TOUT']/@value" -o " " \
       -v "tag[@key='lavfi.signalstats.BRNG']/@value" -o " " \
       -v "tag[@key='lavfi.signalstats.SATMAX']/@value" -o " " \
       -v "tag[@key='lavfi.signalstats.SATAVG']/@value" -o " " \
       -v "tag[@key='lavfi.ssim.Y']/@value" -o " " \
       -v "tag[@key='lavfi.ssim.U']/@value" -o " " \
       -v "tag[@key='lavfi.ssim.V']/@value" -n > "${qctools_CONFIGFILE_V}"

    # determine SATURATION scale
    VBitdepth="$("${ZCAT_COMMAND}" "$1" | perl -nle 'print if not m{<frame|</frame|<tag}' | xmlstarlet sel -t -v "//stream[@codec_type='video']/@pix_fmt" -n
    )"
    if [[ "${VBitdepth}" = "yuv422p10le" ]] ; then
        SATpalette="(0'#a0a0a0',80'#bebebe',177.4'#c8c800',322'#a0ff20',354.8'#00ff00',413.8'#006400',433.46'#00ff00',453.13'#a0ff20',472.8'#ffa500',496'#ff0000')"
        SATcbrange="[0:496]"
        SATyrange="[0:725]"
    else
        SATpalette="(0'#a0a0a0',20'#bebebe',44.35'#c8c800',80'#a0ff20',88.7'#00ff00',103.45'#006400',108.2'#00ff00',113.2'#a0ff20',118.2'#ffa500',124'#ff0000')"
        SATcbrange="[0:124]"
        SATyrange="[0:183]"
    fi

    echo "set terminal jpeg size 1920, 1080
    set output '${LOGDIR}/${FULL_OUTPUT_ID}_QC_output_graphs.jpeg'
    set term jpeg font 'times,12'
    set multiplot layout 7, 1 title '${ID} QC Data Graphs (ver.2)' margins screen .05,.93, .05, .93 spacing screen 0, char .7
    set style line 11 lc rgb '#808080' lt 1
    set border 15 back ls 11
    set format x '%tH:%tM:%.1tS' time
    set format x2 '%tH:%tM:%.1tS' time
    set x2tics border out nomirror
    set xtics border mirror in scale 1.5,.7 format ''
    set ytics border out nomirror font 'times,10'
    set grid y
    set grid x
    set grid mxtics
    set colorbox vertical back user origin graph 1.01,0 size char 1,6
    set cbtics font 'times,10'
    set key inside right top reverse samplen .00
    unset key
    set yrange [-2147483648.:2147483648.]
    set palette model RGB defined (-0.8'#ff0000',-0.6'#ffa500',-0.4'#a0ff20',-0.2'#00ff00',0'#006400',0.2'#00ff00',0.4'#a0ff20',.6'#ffa500',0.8'#ff0000') maxcolors 128
    set cbrange [-2147483648.:2147483648.]
    set style fill solid
    set label 1 'Min/Max Level' at graph .5,.9 center front
    plot '${qctools_CONFIGFILE_A}' using 1:2:2 with boxes palette title 'Max Level', '' using 1:3:3 with boxes palette title 'Min Level'
    unset cbrange
    unset x2tics
    set yrange [-70:0]
    set cbrange [0:-50.]
    set palette model RGB defined (-50'#006400',-35'#00ff00',-15'#a0ff20',-5'#ffa500',-0.5'#ff0000') maxcolors 128
    set style line 15 linecolor palette lw 4
    set label 1 'Peak Level (dB)' at graph .5,.9 front
    plot '' using 1:4:4 with lines ls 15 title 'Peak Level (dB)'
    unset yrange
    unset cbrange
    set palette model RGB defined (-0.8'#ff0000',-0.6'#ffa500',-0.4'#a0ff20',0'#00ff00',1'#006400') maxcolors 128
    set cbrange [-0.8:1]
    set yrange [-1:1]
    set style line 25 linecolor palette lw 4
    set label 1 'Audio Phase' at graph .5,.9 front
    plot '' using 1:5:5 with lines ls 25 title 'Audio Phase'
    unset yrange
    unset cbrange
    set palette model RGB defined (0'#006400',0.01'#00ff00',0.02'#fffb20',.04'#ffa500',0.05'#ff0000') maxcolors 128
    set cbrange [0:.05]
    set yrange [0:.1]
    set label 1 '% Outside of Broadcast Range' at graph .5,.9 front
    plot '${qctools_CONFIGFILE_V}' using 1:3:3 with boxes palette title '% Outside of Broadcast Range'
    unset yrange
    set style line 10 linecolor '#804080' lw 2
    set label 1 '% Temporal OUTliers' at graph .5,.9 front
    plot '' using 1:2 with lines ls 10 title '% Temporal OUTliers'
    unset yrange
    unset cbrange
    set style line 1 linecolor '#f03232' lw 2
    set style line 2 linecolor '#006400' lw 2
    set style line 3 linecolor '#00ff00' lw 2
    set style line 4 linecolor '#f03232' lw 2
    set style line 5 linecolor '#000000' lw 2
    set style line 6 linecolor '#00008b' lw 2
    set yrange ${SATyrange}
    set palette model RGB defined ${SATpalette} maxcolors 128
    set cbrange ${SATcbrange}
    unset label
    set key at graph 1.06,.5 center vertical Left noopaque noreverse font 'times,9'
    set label 1 'Saturation Level' at graph .5,.9 center front
    plot '' using 1:4:4 with boxes palette title 'SatMax', '' using 1:5 with lines ls 5 title 'SatAvg'
    unset yrange
    unset cbrange
    unset xtics
    unset key
    set key at graph 1.06,.5 right vertical Right noopaque noreverse
    set x2tics border mirror in scale 1.5,.7 format ''
    set xtics border out nomirror format '%tH:%tM:%.1tS' time
    set label 1 'Structural SImilarity Metric' at graph .5,.1 center front
    plot '' using 1:6 with lines ls 5 title 'SSIM-Y', '' using 1:7 with lines ls 2 title 'SSIM-U', '' using 1:8 with lines ls 6 title 'SSIM-V'
    " | gnuplot
}

# decipher vrecord options as specified by user
_lookup_choice(){
    case "${2}" in
        "quit"|"Quit"|"QUIT"|"q"|"Q") _report -dt "Bye." ; exit ;;
    esac
    case "${1}" in
        # video inputs
        "Composite") VIDEO_INPUT="composite" ; BMD_VIDEO_INPUT="1" ;;
        "SDI")       VIDEO_INPUT="sdi";        BMD_VIDEO_INPUT="4" ;;
        "Component") VIDEO_INPUT="component";  BMD_VIDEO_INPUT="2" ;;
        "S-Video")   VIDEO_INPUT="s_video";    BMD_VIDEO_INPUT="6" ;;

        # audio inputs
        "Analog")                  AUDIO_INPUT="analog" ;   BMD_AUDIO_INPUT="1" ;;
        "SDI Embedded Audio")      AUDIO_INPUT="embedded" ; BMD_AUDIO_INPUT="2"  ;;
        "Digital Audio (AES/EBU)") AUDIO_INPUT="aes_ebu" ;  BMD_AUDIO_INPUT="3"  ;;

        # container
        "QuickTime")
            EXTENSION="mov"
            MIDDLEOPTIONS+=(-movflags write_colr)
            FORMAT="mov" ;;
        "Matroska")
            EXTENSION="mkv"
            FORMAT="matroska" ;;
        "AVI")
            EXTENSION="avi"
            FORMAT="avi" ;;
        "MXF")
            EXTENSION="mxf"
            FORMAT="mxf" ;;
        "MP4")
            EXTENSION="mp4"
            MIDDLEOPTIONS+=(-movflags write_colr)
            FORMAT="mp4" ;;

        # video codec
        "Uncompressed Video")
            if [[ "${PIXEL_FORMAT}" = "yuv422p10" ]] ; then
                VIDEOCODECNAME="Uncompressed 10-bit 4:2:2"
                MIDDLEOPTIONS+=(-c:v v210)
            elif [[ "${PIXEL_FORMAT}" = "uyvy422" ]] ; then
                VIDEOCODECNAME="Uncompressed 8-bit 4:2:2"
                MIDDLEOPTIONS+=(-c:v rawvideo -pix_fmt uyvy422 -tag:v 2vuy)
            fi ;;
        "FFV1 version 3")
            VIDEOCODECNAME="FFV1 version 3"
            MIDDLEOPTIONS+=(-c:v ffv1 -level 3 -g 1 -slices "${FFV1_SLICE_CHOICE}" -slicecrc 1)
            SUFFIX="_ffv1" ;;
        "JPEG2000")
            VIDEOCODECNAME="JPEG2000"
            MIDDLEOPTIONS+=(-c:v libopenjpeg)
            SUFFIX="_j2k" ;;
        "ProRes")
            VIDEOCODECNAME="Apple ProRes 422"
            MIDDLEOPTIONS+=(-c:v prores_ks -flags +ildct -profile:v 2)
            SUFFIX="_prores" ;;
        "ProRes (HQ)")
            VIDEOCODECNAME="Apple ProRes 422 HQ"
            MIDDLEOPTIONS+=(-c:v prores_ks -flags +ildct -profile:v 3)
            SUFFIX="_prores" ;;
        "h264")
            VIDEOCODECNAME="H.264"
            MIDDLEOPTIONS+=(-c:v libx264 -crf 18 -pix_fmt yuv420p)
            SUFFIX="" ;;
        "HuffYUV")
            VIDEOCODECNAME="HuffYUV"
            if [[ "${PIXEL_FORMAT}" = "yuv422p10" ]] ; then
                MIDDLEOPTIONS+=(-c:v ffvhuff -pix_fmt yuv422p10le -pred median -context 1)
            elif [[ "${PIXEL_FORMAT}" = "uyvy422" ]] ; then
                MIDDLEOPTIONS+=(-c:v ffvhuff -pix_fmt yuv422p -pred median -context 1)
            fi
            SUFFIX="_huff" ;;

        # video pixel format and bit depth
        "10 bit") PIXEL_FORMAT="yuv422p10" ; BMD_PIXEL_FORMAT="yuv10" ;;
        "8 bit")  PIXEL_FORMAT="uyvy422" ;   BMD_PIXEL_FORMAT="yuv8" ;;

        # audio codec
        "24-bit PCM")
            MIDDLEOPTIONS+=(-c:a pcm_s24le)
            AUDIO_EXT='wav' ;;
        "24-bit FLAC")
            MIDDLEOPTIONS+=(-c:a flac)
            MIDDLEOPTIONS+=(-sample_fmt s32)
            AUDIO_EXT='flac' ;;
        "AAC")
            MIDDLEOPTIONS+=(-c:a aac) ;;

        # audio mappings
        "2 Stereo Tracks (Channels 1 & 2 -> 1st Track Stereo, Channels 3 & 4 -> 2nd Track Stereo)")
            AUDIOMAP="[0:a:0]pan=stereo| c0=c0 | c1=${PHASE_VALUE}c1[stereo1];[0:a:0]pan=stereo| c0=c2 | c1=c3[stereo2]"
            AUDIO_CHANNEL_MAP+=(-map "[stereo1]")
            AUDIO_CHANNEL_MAP+=(-map "[stereo2]") ;;
        "1 Stereo Track (From Channels 1 & 2)")
            AUDIOMAP="[0:a:0]pan=stereo| c0=c0 | c1=${PHASE_VALUE}c1[stereo1]"
            AUDIO_CHANNEL_MAP+=(-map "[stereo1]") ;;
        "1 Stereo Track (From Channels 3 & 4)")
            AUDIOMAP="[0:a:0]pan=stereo| c0=c2 | c1=${PHASE_VALUE}c3[stereo1]"
            AUDIO_CHANNEL_MAP+=(-map "[stereo1]") ;;
        "Channel 1 -> 1st Track Mono, Channel 2 -> 2nd Track Mono")
            AUDIOMAP="[0:a:0]pan=mono| c0=c0[mono1];[0:a:0]pan=mono| c0=${PHASE_VALUE}c1[mono2]"
            AUDIO_CHANNEL_MAP+=(-map "[mono1]")
            AUDIO_CHANNEL_MAP+=(-map "[mono2]") ;;
        "Channel 2 -> 1st Track Mono, Channel 1 -> 2nd Track Mono")
            AUDIOMAP="[0:a:0]pan=mono| c0=${PHASE_VALUE}c1[mono1];[0:a:0]pan=mono| c0=c0[mono2]"
            AUDIO_CHANNEL_MAP+=(-map "[mono1]")
            AUDIO_CHANNEL_MAP+=(-map "[mono2]") ;;
        "Channel 1 -> Single Track Mono")
            AUDIOMAP="[0:a:0]pan=mono| c0=c0[mono1]"
            AUDIO_CHANNEL_MAP+=(-map "[mono1]") ;;
        "Channel 2 -> Single Track Mono")
            AUDIOMAP="[0:a:0]pan=mono| c0=c1[mono1]"
            AUDIO_CHANNEL_MAP+=(-map "[mono1]") ;;
        # Audio mode channel options
        "Mono")
            AUDIOMAP="[0:a:0]pan=mono| c0=c0[mono1]"
            PASSTHROUGH_MAP="pan=mono|c0=c0"
            AUDIO_CHANNEL_MAP+=(-map "[mono1]") ;;
        "Stereo")
            AUDIOMAP="[0:a:0]pan=stereo| c0=c0 | c1=c1[stereo1]"
            PASSTHROUGH_MAP="pan=stereo|c0=c0|c1=c1"
            AUDIO_CHANNEL_MAP+=(-map "[stereo1]") ;;
        # Audio mode sample rate options
        "96 kHz")
            S_RATE='-ar 96k'
            MIDDLEOPTIONS+=(${S_RATE}) ;;
        "48 kHz")
            S_RATE='-ar 48k'
            MIDDLEOPTIONS+=(${S_RATE}) ;;
        "44.1 kHz")
            S_RATE='-ar 44.1k'
            MIDDLEOPTIONS+=(${S_RATE}) ;;
        # timecode options
        "none"|"rp188vitc"|"rp188vitc2"|"rp188ltc"|"rp188any"|"vitc"|"vitc2"|"serial")
            TC_TYPE="${1}"
            EXTRAINPUTOPTIONS+=(-timecode_format "${TC_TYPE}")
            MIDDLEOPTIONS+=(-map_metadata 0:s:v:0)
            if [[ "${TC_TYPE}" != "none" ]] ; then
                if [[ "${RUNTYPE}" = "passthrough" ]] ; then
                TIMECODE_OVERLAY=",drawtext=fontfile=${DEFAULTFONT}:x=(w-text_w)*0.5:y=(h-text_h)*0.75:fontcolor=white:box=1:boxcolor=gray@0.7:boxborderw=4:fontsize=22:shadowx=1:shadowy=1:text=%{metadata\\\:timecode\\\:no ${TC_TYPE} timecode}"
                fi
                TC_TMP=$(_maketemp .timecode.txt)
                TC_WRITE=",metadata=mode=print:file=${TC_TMP}"
            fi
            declare TC_TYPE "${TC_TYPE}"
            ;;
        # video standard
        "NTSC")
            STANDARD="ntsc"
            if [[ "${DECKLINK_UTILITY_CHOICE}" == "bmdcapture" ]] ; then
                BMD_STANDARD="$(bmdcapture -h 2>&1 | grep "NTSC.*29.97" | cut -d: -f 1 | sed 's/ //g' | head -n 1)"
                RECORDINGFILTER+="setfield=bff,"
            fi
            DECKLINK_FPS="30000/1001"
            if [[ "${VIDEO_CODEC_CHOICE}" = "h264" ]] ; then
                RECORDINGFILTER+="crop=w=720:h=480:x=0:y=4,"
                MIDDLEOPTIONS+=(-x264opts bff)
            fi
            RECORDINGFILTER+="setsar=40/27,setdar=4/3"
            MIDDLEOPTIONS+=(-color_primaries smpte170m)
            MIDDLEOPTIONS+=(-color_trc bt709)
            MIDDLEOPTIONS+=(-colorspace smpte170m) ;;
        "PAL")
            STANDARD="pal "
            if [[ "${DECKLINK_UTILITY_CHOICE}" == "bmdcapture" ]] ; then
                BMD_STANDARD="$(bmdcapture -h 2>&1 | grep "PAL.*25" | cut -d: -f 1 | sed 's/ //g' | head -n 1)"
                RECORDINGFILTER+="setfield=tff,"
            fi
            DECKLINK_FPS="25000/1000"
            if [[ "${VIDEO_CODEC_CHOICE}" = "h264" ]] ; then
                MIDDLEOPTIONS+=(-x264opts tff)
            fi
            RECORDINGFILTER+="setsar=16/15,setdar=4/3"
            MIDDLEOPTIONS+=(-color_primaries bt470bg)
            MIDDLEOPTIONS+=(-color_trc bt709)
            MIDDLEOPTIONS+=(-colorspace bt470bg) ;;

        # playback views
        "Unfiltered") PLAYBACKFILTER="" ;;
        "Quality Control View (mpv)") MEDIA_PLAYER_CHOICE="mpv" ;;
        "Audio")
if [[ "${RUNTYPE}" = "record" ]] ; then
    AUDIO_SPLIT='4[c][e][f][out1],'
    WAVEFORM="[e]astats=metadata=1:reset=1,adrawgraph=m1=lavfi.astats.1.Min_level:m2=lavfi.astats.1.Max_level:size=700x160:bg=Black:fg1=0xFFFF0000:fg2=0xFFFF0000:slide=scroll:min=-32767:max=32767[wav1],\
    [f]astats=metadata=1:reset=1,adrawgraph=m1=lavfi.astats.2.Min_level:m2=lavfi.astats.2.Max_level:size=700x160:bg=Black:fg1=0xFF00FF00:fg2=0xFF00FF00:slide=scroll:min=-32767:max=32767[wav2]"
    AP_MAP='[c1][wav1][wav2]xstack=inputs=3:layout=0_0|0_h0|0_h0+h1[out0]'
else
    PRINT_PHASE=",drawtext=fontfile=${DEFAULTFONT}:box=1:text=Phase\\\: %{metadata\\\:lavfi.aphasemeter.phase}:x=135:y=380:fontcolor=black"
    PRINT_CHANNELS_1_2=",drawtext=fontfile=${DEFAULTFONT}:text=Ch.1/2:x=10: y=10:fontcolor=white"
    AUDIO_SPLIT='7[a][b][c][d][e][f][out1],'
    WAVEFORM="[e]astats=metadata=1:reset=1,adrawgraph=m1=lavfi.astats.1.Min_level:m2=lavfi.astats.1.Max_level:size=700x160:bg=Black:fg1=0xFFFF0000:fg2=0xFFFF0000:slide=scroll:min=-32767:max=32767[wav1],\
    [f]astats=metadata=1:reset=1,adrawgraph=m1=lavfi.astats.2.Min_level:m2=lavfi.astats.2.Max_level:size=700x160:bg=Black:fg1=0xFF00FF00:fg2=0xFF00FF00:slide=scroll:min=-32767:max=32767[wav2]"
    CHANNEL_PARAMS="[b]avectorscope=s=320x400${PRINT_CHANNELS_1_2}[b1],"
    AP_MAP='[a1][b1][x][wav1][wav2]xstack=inputs=5:layout=0_0|w0_0|0_h0|w0+w1_0|w0+w1_h3,fps=25[out0]'
    PHASE_LOCATION='x=135:y=380'
    SHOW_SPECTUM="[d]showspectrum=s=1155x200:fps=10:color=rainbow:saturation=2:legend=1[d1],"
    VOLUME_OVERLAY='[d1][c1]overlay=640:0:format=yuv444[x],'
    PHASE_MAP="[a]aphasemeter=video=0,adrawgraph=lavfi.aphasemeter.phase:max=1:min=-1:size=320x400:bg=black:fg1=0x99999999,drawbox=x=0:y=200:w=400:c=white:h=1${PRINT_PHASE}${PRINT_CHANNELS_1_2}[a1],"
fi
PLAYBACKFILTER="${PASSTHROUGH_MAP},asplit=${AUDIO_SPLIT}\
${PHASE_MAP}\
${CHANNEL_PARAMS}\
${WAVEFORM},\
[c]showvolume=t=0:h=28:w=700[c1],\
${SHOW_SPECTUM}\
${VOLUME_OVERLAY}\
${AP_MAP}" ;;
        "Audio + Video")
            VECTORSCOPE_FILTER="\
format=yuv422p,\
vectorscope=i=0.04:mode=color2:c=1:envelope=instant:graticule=green:flags=name,\
scale=400:400"
if [[ "${AUDIO_MAPPING_CHOICE}" = '2 Stereo Tracks (Channels 1 & 2 -> 1st Track Stereo, Channels 3 & 4 -> 2nd Track Stereo)' ]] ; then
    PRINT_PHASE=",drawtext=fontfile=${DEFAULTFONT}:box=1:text=Phase\\\: %{metadata\\\:lavfi.aphasemeter.phase}:x=135:y=180:fontcolor=black"
    PRINT_CHANNELS_1_2=",drawtext=fontfile=${DEFAULTFONT}:text=Ch.1/2:x=10: y=10:fontcolor=white"
    PRINT_CHANNELS_3_4=",drawtext=fontfile=${DEFAULTFONT}:text=Ch.3/4:x=10: y=10:fontcolor=white"
    AUDIO_SPLIT='7[a][aa][b][c][d][e][out1]'
    CHANNEL_PARAMS="[b]pan=stereo|c0=c0|c1=c1,avectorscope=s=320x400${PRINT_CHANNELS_1_2}[b1],[e]pan=stereo|c0=c2|c1=c3,avectorscope=s=320x400${PRINT_CHANNELS_3_4}[e1]"
    AP_MAP='[phase1][phase2][b1][e1][x][d1][TFIELD][BFIELD][vector]xstack=inputs=9:layout=0_0|0_h0|w0_0|w0+w2_0|w0+w2+w3_0|0_h0+h1|0_h0+h1+h5|w6_h0+h1+h5|w5_h0+h1,fps=25[out0]'
    PHASE_LOCATION='x=135:y=180'
    PHASE_MAP="[a]pan=stereo|c0=c0|c1=c1,aphasemeter=video=0,adrawgraph=lavfi.aphasemeter.phase:max=1:min=-1:size=400x200:bg=black:fg1=0x99999999,drawbox=x=0:y=100:w=400:c=white:h=1${PRINT_PHASE}${PRINT_CHANNELS_1_2}[phase1],\
    [aa]pan=stereo|c0=c2|c1=c3,aphasemeter=video=0,adrawgraph=lavfi.aphasemeter.phase:max=1:min=-1:size=400x200:bg=black:fg1=0x99999999,drawbox=x=0:y=100:w=400:c=white:h=1${PRINT_PHASE}${PRINT_CHANNELS_3_4}[phase2]"
    SPECTRUM_SIZE='755x265'
else
    PRINT_PHASE=",drawtext=fontfile=${DEFAULTFONT}:box=1:text=Phase\\\: %{metadata\\\:lavfi.aphasemeter.phase}:x=135:y=380:fontcolor=black"
    PRINT_CHANNELS_1_2=",drawtext=fontfile=${DEFAULTFONT}:text=Ch.1/2:x=10: y=10:fontcolor=white"
    AUDIO_SPLIT='5[a][b][c][d][out1]'
    CHANNEL_PARAMS="[b]pan=stereo|c0=c0|c1=c1,avectorscope=s=320x400${PRINT_CHANNELS_1_2}[b1]"
    AP_MAP='[a1][b1][x][d1][TFIELD][BFIELD][vector]xstack=inputs=7:layout=0_0|w0_0|w0+w1_0|0_h0+h4|0_h0|w4_h0|w0+w1+w2_0,fps=25[out0]'
    PHASE_LOCATION='x=135:y=380'
    PHASE_MAP="[a]aphasemeter=video=0,adrawgraph=lavfi.aphasemeter.phase:max=1:min=-1:size=320x400:bg=black:fg1=0x99999999,drawbox=x=0:y=200:w=400:c=white:h=1${PRINT_PHASE}${PRINT_CHANNELS_1_2}[a1]"
    SPECTRUM_SIZE='1155x200'
fi
PLAYBACKFILTER="streams=dv+da[vid][aud],[aud]asplit=${AUDIO_SPLIT},\
${PHASE_MAP},\
${CHANNEL_PARAMS},\
[c]showvolume=t=0:h=17:w=200[c1],\
[d]showspectrum=s=${SPECTRUM_SIZE}:fps=10:color=rainbow:saturation=2:legend=1[d1],\
[vid]split=4[vid1][vid2][vid3][vid4],[vid1]scale=400x400,signalstats=out=brng[vidscale],\
[vid2]field=top,${WAVEFORM_FILTER}[TFIELD],\
[vid3]field=bottom,${WAVEFORM_FILTER}[BFIELD],\
[vid4]${VECTORSCOPE_FILTER}[vector],\
[vidscale][c1]overlay=10:10[x],\
${AP_MAP}" ;;
        "Broadcast Range Visual")
            PLAYBACKFILTER="\
${PLAYBACK_FILTER_ADJUSTMENT}split=5[a][b][c][d][e];\
[a]copy${TIMECODE_OVERLAY}[a1];\
[b]field=top,${WAVEFORM_FILTER}[b1];\
[c]field=bottom,${WAVEFORM_FILTER}[c1];\
[d]${VECTORSCOPE_FILTER}[d1];\
[e]scale=512:ih,signalstats=out=brng[e1];\
[a1][b1][c1][e1][d1]xstack=inputs=5:layout=0_0|0_h0|0_h0+h1|w0_0|w0_h0" ;;
        "Full Range Visual")
            PLAYBACKFILTER="\
${PLAYBACK_FILTER_ADJUSTMENT}split=5[a][b][c][d][e];\
[a]copy${TIMECODE_OVERLAY}[a1];\
[b]field=top,${WAVEFORM_FILTER}[b1];\
[c]field=bottom,${WAVEFORM_FILTER}[c1];\
[d]${VECTORSCOPE_FILTER}[d1];\
[e]format=yuv444p,pseudocolor=if(between(1\,val\,amax)+between(val\,254\,amax)\,65\,-1):if(between(1\,val\,amax)+between(val\,254\,amax)\,100\,-1):if(between(1\,val\,amax)+between(val\,254\,amax)\,212\,-1),scale=512:ih[e1];\
[a1][b1][c1][e1][d1]xstack=inputs=5:layout=0_0|0_h0|0_h0+h1|w0_0|w0_h0" ;;
      "Visual + Numerical")
          _set_up_drawtext
          PLAYBACKFILTER="\
${PLAYBACK_FILTER_ADJUSTMENT}split=6[a][b][c][d][e][f];\
[a]copy${TIMECODE_OVERLAY}[a1];\
[b]field=top,${WAVEFORM_FILTER}[b1];\
[c]field=bottom,${WAVEFORM_FILTER}[c1];\
[d]${VECTORSCOPE_FILTER}[d1];\
[e]signalstats=out=brng:stat=brng+vrep+tout,scale=512:ih,split[e1][e2];\
[e2]format=yuv422p,geq=lum=60:cb=128:cr=128,\
scale=180:ih+512,setsar=1/1,\
drawtext=fontcolor=white:fontsize=22:\
fontfile=${DEFAULTFONT}:textfile=${DRAWTEXT_TMP_1},\
drawtext=fontcolor=white:fontsize=17:\
fontfile=${DEFAULTFONT}:textfile=${DRAWTEXT_TMP_2}:y=480,\
drawtext=fontcolor=white:fontsize=52:\
fontfile=${DEFAULTFONT}:textfile=${DRAWTEXT_TMP_3}:y=640[e3];\
[f]scale=iw+512+180:82,format=yuv422p,geq=lum=60:cb=128:cr=128,drawtext=fontcolor=white:fontsize=22:\
fontfile=${DEFAULTFONT}:textfile=${VRECORD_INPUT_TMP}:\
reload=1:y=82-th[f1];\
[e3][a1][b1][c1][e1][d1][f1]xstack=inputs=7:layout=0_0|w0_0|w0_h1|w0_h1+h2|w0+w1_0|w0+w1_h1|0_h0" ;;
      "Color Matrix")
          HUE=20
          SAT=0.3
          PLAYBACKFILTER="\
${PLAYBACK_FILTER_ADJUSTMENT}scale=iw/4:ih/4,\
split=9[x][hm][hp][sm][sp][hmsm][hmsp][hpsm][hpsp];\
[hm]hue=h=-${HUE}[hm1];\
[hp]hue=h=${HUE}[hp1];\
[sm]hue=s=1-${SAT}[sm1];\
[sp]hue=s=1+${SAT}[sp1];\
[hmsm]hue=h=-${HUE}:s=1-${SAT}[hmsm1];\
[hmsp]hue=h=-${HUE}:s=1+${SAT}[hmsp1];\
[hpsm]hue=h=${HUE}:s=1-${SAT}[hpsm1];\
[hpsp]hue=h=${HUE}:s=1+${SAT}[hpsp1];\
[hpsm1][hp1][hpsp1][sm1][x][sp1][hmsm1][hm1][hmsp1]xstack=inputs=9:layout=0_0|0_h0|0_h0+h1|w0_0|w0_h0|w0_h0+h1|w0+w1_0|w0+w1_h0|w0+w1_h0+h1" ;;
      "Bit Planes")
          if [[ "${PIXEL_FORMAT}" = "uyvy422" ]] ; then
              BITS=8
              SPLIT="8[b0][b1][b2][b3][b4][b5][b6][b7]"
              STACK="[b0c][b1c][b2c][b3c][b4c][b5c][b6c][b7c]hstack=8,format=yuv444p,drawgrid=w=iw/8:h=ih:t=2:c=green@0.5"
          elif [[ "${PIXEL_FORMAT}" = "yuv422p10" ]] ; then
              BITS=10
              SPLIT="10[b0][b1][b2][b3][b4][b5][b6][b7][b8][b9]"
              STACK="\
[b8]bitplanenoise=bitplane=2,crop=iw/10:ih:(iw/10)*8:0,lutyuv=u=(maxval/2):v=(maxval/2):y=bitand(val\\,pow(2\\,10-9))*pow(2\\,9),pad=iw:ih+64:0:64,drawtext=fontfile=${DEFAULTFONT}:text=%{metadata\\\:lavfi.bitplanenoise.0.2}:y=0:fontcolor=white:fontsize=20,drawtext=fontfile=${DEFAULTFONT}:text=%{metadata\\\:lavfi.bitplanenoise.1.2}:y=20:fontcolor=white:fontsize=20,drawtext=fontfile=${DEFAULTFONT}:text=%{metadata\\\:lavfi.bitplanenoise.2.2}:y=40:fontcolor=white:fontsize=20[b8c];\
[b9]bitplanenoise=bitplane=1,crop=iw/10:ih:(iw/10)*9:0,lutyuv=u=(maxval/2):v=(maxval/2):y=bitand(val\\,pow(2\\,10-10))*pow(2\\,10),pad=iw:ih+64:0:64,drawtext=fontfile=${DEFAULTFONT}:text=%{metadata\\\:lavfi.bitplanenoise.0.1}:y=0:fontcolor=silver:fontsize=20,drawtext=fontfile=${DEFAULTFONT}:text=%{metadata\\\:lavfi.bitplanenoise.1.1}:y=20:fontcolor=silver:fontsize=20,drawtext=fontfile=${DEFAULTFONT}:text=%{metadata\\\:lavfi.bitplanenoise.2.1}:y=40:fontcolor=silver:fontsize=20[b9c];\
[b0c][b1c][b2c][b3c][b4c][b5c][b6c][b7c][b8c][b9c]hstack=10,format=yuv444p,drawgrid=w=iw/10:h=ih:t=2:c=green@0.5"
          fi
          PLAYBACKFILTER="\
${PLAYBACK_FILTER_ADJUSTMENT}format=yuv420p10le|yuv422p10le|yuv444p10le|yuv440p10le,split=${SPLIT};\
[b0]bitplanenoise=bitplane=10,crop=iw/${BITS}:ih:(iw/${BITS})*0:0,lutyuv=u=(maxval/2):v=(maxval/2):y=bitand(val\\,pow(2\\,10-1))*pow(2\\,1),pad=iw:ih+64:0:64,drawtext=fontfile=${DEFAULTFONT}:text=%{metadata\\\:lavfi.bitplanenoise.0.10}:y=0:fontcolor=white:fontsize=20,drawtext=fontfile=${DEFAULTFONT}:text=%{metadata\\\:lavfi.bitplanenoise.1.10}:y=20:fontcolor=white:fontsize=20,drawtext=fontfile=${DEFAULTFONT}:text=%{metadata\\\:lavfi.bitplanenoise.2.10}:y=40:fontcolor=white:fontsize=20[b0c];\
[b1]bitplanenoise=bitplane=9,crop=iw/${BITS}:ih:(iw/${BITS})*1:0,lutyuv=u=(maxval/2):v=(maxval/2):y=bitand(val\\,pow(2\\,10-2))*pow(2\\,2),pad=iw:ih+64:0:64,drawtext=fontfile=${DEFAULTFONT}:text=%{metadata\\\:lavfi.bitplanenoise.0.9}:y=0:fontcolor=silver:fontsize=20,drawtext=fontfile=${DEFAULTFONT}:text=%{metadata\\\:lavfi.bitplanenoise.1.9}:y=20:fontcolor=silver:fontsize=20,drawtext=fontfile=${DEFAULTFONT}:text=%{metadata\\\:lavfi.bitplanenoise.2.9}:y=40:fontcolor=silver:fontsize=20[b1c];\
[b2]bitplanenoise=bitplane=8,crop=iw/${BITS}:ih:(iw/${BITS})*2:0,lutyuv=u=(maxval/2):v=(maxval/2):y=bitand(val\\,pow(2\\,10-3))*pow(2\\,3),pad=iw:ih+64:0:64,drawtext=fontfile=${DEFAULTFONT}:text=%{metadata\\\:lavfi.bitplanenoise.0.8}:y=0:fontcolor=white:fontsize=20,drawtext=fontfile=${DEFAULTFONT}:text=%{metadata\\\:lavfi.bitplanenoise.1.8}:y=20:fontcolor=white:fontsize=20,drawtext=fontfile=${DEFAULTFONT}:text=%{metadata\\\:lavfi.bitplanenoise.2.8}:y=40:fontcolor=white:fontsize=20[b2c];\
[b3]bitplanenoise=bitplane=7,crop=iw/${BITS}:ih:(iw/${BITS})*3:0,lutyuv=u=(maxval/2):v=(maxval/2):y=bitand(val\\,pow(2\\,10-4))*pow(2\\,4),pad=iw:ih+64:0:64,drawtext=fontfile=${DEFAULTFONT}:text=%{metadata\\\:lavfi.bitplanenoise.0.7}:y=0:fontcolor=silver:fontsize=20,drawtext=fontfile=${DEFAULTFONT}:text=%{metadata\\\:lavfi.bitplanenoise.1.7}:y=20:fontcolor=silver:fontsize=20,drawtext=fontfile=${DEFAULTFONT}:text=%{metadata\\\:lavfi.bitplanenoise.2.7}:y=40:fontcolor=silver:fontsize=20[b3c];\
[b4]bitplanenoise=bitplane=6,crop=iw/${BITS}:ih:(iw/${BITS})*4:0,lutyuv=u=(maxval/2):v=(maxval/2):y=bitand(val\\,pow(2\\,10-5))*pow(2\\,5),pad=iw:ih+64:0:64,drawtext=fontfile=${DEFAULTFONT}:text=%{metadata\\\:lavfi.bitplanenoise.0.6}:y=0:fontcolor=white:fontsize=20,drawtext=fontfile=${DEFAULTFONT}:text=%{metadata\\\:lavfi.bitplanenoise.1.6}:y=20:fontcolor=white:fontsize=20,drawtext=fontfile=${DEFAULTFONT}:text=%{metadata\\\:lavfi.bitplanenoise.2.6}:y=40:fontcolor=white:fontsize=20[b4c];\
[b5]bitplanenoise=bitplane=5,crop=iw/${BITS}:ih:(iw/${BITS})*5:0,lutyuv=u=(maxval/2):v=(maxval/2):y=bitand(val\\,pow(2\\,10-6))*pow(2\\,6),pad=iw:ih+64:0:64,drawtext=fontfile=${DEFAULTFONT}:text=%{metadata\\\:lavfi.bitplanenoise.0.5}:y=0:fontcolor=silver:fontsize=20,drawtext=fontfile=${DEFAULTFONT}:text=%{metadata\\\:lavfi.bitplanenoise.1.5}:y=20:fontcolor=silver:fontsize=20,drawtext=fontfile=${DEFAULTFONT}:text=%{metadata\\\:lavfi.bitplanenoise.2.5}:y=40:fontcolor=silver:fontsize=20[b5c];\
[b6]bitplanenoise=bitplane=4,crop=iw/${BITS}:ih:(iw/${BITS})*6:0,lutyuv=u=(maxval/2):v=(maxval/2):y=bitand(val\\,pow(2\\,10-7))*pow(2\\,7),pad=iw:ih+64:0:64,drawtext=fontfile=${DEFAULTFONT}:text=%{metadata\\\:lavfi.bitplanenoise.0.4}:y=0:fontcolor=white:fontsize=20,drawtext=fontfile=${DEFAULTFONT}:text=%{metadata\\\:lavfi.bitplanenoise.1.4}:y=20:fontcolor=white:fontsize=20,drawtext=fontfile=${DEFAULTFONT}:text=%{metadata\\\:lavfi.bitplanenoise.2.4}:y=40:fontcolor=white:fontsize=20[b6c];\
[b7]bitplanenoise=bitplane=3,crop=iw/${BITS}:ih:(iw/${BITS})*7:0,lutyuv=u=(maxval/2):v=(maxval/2):y=bitand(val\\,pow(2\\,10-8))*pow(2\\,8),pad=iw:ih+64:0:64,drawtext=fontfile=${DEFAULTFONT}:text=%{metadata\\\:lavfi.bitplanenoise.0.3}:y=0:fontcolor=silver:fontsize=20,drawtext=fontfile=${DEFAULTFONT}:text=%{metadata\\\:lavfi.bitplanenoise.1.3}:y=20:fontcolor=silver:fontsize=20,drawtext=fontfile=${DEFAULTFONT}:text=%{metadata\\\:lavfi.bitplanenoise.2.3}:y=40:fontcolor=silver:fontsize=20[b7c];\
${STACK}" ;;

        # others
        "Yes"|"Yes, after recording"|"Yes, concurrent with recording"|"No") ;;
        *) _report -w "Error: ${1} is not a valid option." ; return 1 ;;
    esac
}

_frames_to_hhmmss(){
    H=$(echo "${i} / (60 * 60 * ${DECKLINK_FPS})" | bc)
    M=$(echo "(${i} - (${H}*60 * 60 * ${DECKLINK_FPS})) / (60 * ${DECKLINK_FPS})" | bc)
    S="$(echo "scale=3;(${i} - (${H}*60 * 60 * ${DECKLINK_FPS})-($M*60*${DECKLINK_FPS})) / (${DECKLINK_FPS})" | bc)"
    Ss=$(echo "${S}" | cut -d. -f1 | bc)
    Sm=$(echo "${S}" | cut -d. -f2 | bc)
    printf "%02d:%02d:%02d.%03d\n" "${H}" "${M}" "${Ss}" "${Sm}"
}

_set_up_drawtext(){
    # set up drawtext.txt files for Visual + Numerical playback view
    DRAWTEXT_TMP_1="$(_maketemp .drawtext.1.txt)"
    DRAWTEXT_TMP_2="$(_maketemp .drawtext.2.txt)"
    DRAWTEXT_TMP_3="$(_maketemp .drawtext.3.txt)"
    echo "%{pts:hms}

  Y
 Low  %{metadata:lavfi.signalstats.YLOW}
 Avg  %{metadata:lavfi.signalstats.YAVG}
 High %{metadata:lavfi.signalstats.YHIGH}
 Diff %{metadata:lavfi.signalstats.YDIF}

  U
 Low  %{metadata:lavfi.signalstats.ULOW}
 Avg  %{metadata:lavfi.signalstats.UAVG}
 High %{metadata:lavfi.signalstats.UHIGH}
 Diff %{metadata:lavfi.signalstats.UDIF}

  V
 Low  %{metadata:lavfi.signalstats.VLOW}
 Avg  %{metadata:lavfi.signalstats.VAVG}
 High %{metadata:lavfi.signalstats.VHIGH}
 Diff %{metadata:lavfi.signalstats.VDIF}

  SAT
 Low  %{metadata:lavfi.signalstats.SATLOW}
 Avg  %{metadata:lavfi.signalstats.SATAVG}
 High %{metadata:lavfi.signalstats.SATHIGH}" > "${DRAWTEXT_TMP_1}"

    echo " HUE(med) %{metadata:lavfi.signalstats.HUEMED}
 HUE(avg) %{metadata:lavfi.signalstats.HUEAVG}
 TOUT     %{metadata:lavfi.signalstats.TOUT}
 VREP     %{metadata:lavfi.signalstats.VREP}

 Used Bitdepths
 Y        %{metadata:lavfi.signalstats.YBITDEPTH}
 U        %{metadata:lavfi.signalstats.UBITDEPTH}
 V        %{metadata:lavfi.signalstats.VBITDEPTH}" > "${DRAWTEXT_TMP_2}"
    echo "BRNG
%{metadata:lavfi.signalstats.BRNG}" > "${DRAWTEXT_TMP_3}"
}

# select playback view
WAVEFORM_FILTER="\
format=yuv422p,\
waveform=intensity=0.1:mode=column:mirror=1:c=1:f=lowpass:e=instant:graticule=green:flags=numbers+dots"
VECTORSCOPE_FILTER="\
format=yuv422p,\
vectorscope=i=0.04:mode=color2:c=1:envelope=instant:graticule=green:flags=name,\
scale=512:512,\
drawbox=w=9:h=9:t=1:x=128-3:y=512-452-5:c=sienna@0.8,\
drawbox=w=9:h=9:t=1:x=160-3:y=512-404-5:c=sienna@0.8,\
drawbox=w=9:h=9:t=1:x=192-3:y=512-354-5:c=sienna@0.8,\
drawbox=w=9:h=9:t=1:x=224-3:y=512-304-5:c=sienna@0.8,\
drawgrid=w=32:h=32:t=1:c=white@0.1,\
drawgrid=w=256:h=256:t=1:c=white@0.2"

# list of selections for each vrecord option
DECKLINK_UTILITIES=("ffmpeg" "bmdcapture")
VIDEO_INPUT_OPTIONS=("Composite" "SDI" "Component" "S-Video")
AUDIO_INPUT_OPTIONS=("Analog" "SDI Embedded Audio" "Digital Audio (AES/EBU)")
CONTAINER_OPTIONS=("QuickTime" "Matroska" "AVI" "MXF" "MP4")
VIDEO_CODEC_OPTIONS=("Uncompressed Video" "FFV1 version 3" "JPEG2000" "ProRes" "ProRes (HQ)" "h264" "HuffYUV")
FFV1_SLICE_OPTIONS=("4" "6" "9" "12" "16" "24" "30")
AUDIO_CODEC_OPTIONS=("24-bit PCM" "24-bit FLAC" "AAC")
AUDIO_CHANNEL_CHOICE_OPTIONS=("Mono" "Stereo")
AUDIO_MODE_SR_CHOICE_OPTIONS=("96 kHz" "48 kHz" "44.1 kHz")
VIDEO_BITDEPTH_OPTIONS=("10 bit" "8 bit")
CHANNEL_MAPPING_OPTIONS=("2 Stereo Tracks (Channels 1 & 2 -> 1st Track Stereo, Channels 3 & 4 -> 2nd Track Stereo)" "1 Stereo Track (From Channels 1 & 2)" "1 Stereo Track (From Channels 3 & 4)" "Channel 1 -> 1st Track Mono, Channel 2 -> 2nd Track Mono" "Channel 2 -> 1st Track Mono, Channel 1 -> 2nd Track Mono" "Channel 1 -> Single Track Mono" "Channel 2 -> Single Track Mono")
TIMECODE_OPTIONS=("none" "rp188vitc" "rp188vitc2" "rp188ltc" "rp188any" "vitc" "vitc2" "serial")
STANDARD_OPTIONS=("NTSC" "PAL")
QCTOOLSXML_OPTIONS=("Yes, after recording" "Yes, concurrent with recording" "No")
FRAMEMD5_OPTIONS=("Yes" "No")
EMBED_LOGS_OPTIONS=("Yes" "No")
PLAYBACKVIEW_OPTIONS=("Unfiltered" "Quality Control View (mpv)" "Broadcast Range Visual" "Full Range Visual" "Visual + Numerical" "Color Matrix" "Bit Planes")
PLAYBACKVIEW_PASS_OPTIONS=("Unfiltered" "Quality Control View (mpv)" "Broadcast Range Visual" "Audio + Video" "Full Range Visual" "Visual + Numerical" "Color Matrix" "Bit Planes")

# GUI mode + CLI reset, edit modes
if [[ "${RUNTYPE}" = "reset" ]] ; then
    _report -q -n "Resetting the configuration will clear ${CONFIG_FILE}. Please enter [Y] to confirm: "
    read RESET_RESPONSE
    if [[ "${RESET_RESPONSE}" = [Yy] ]] ; then
        _report -d "Clearing ${CONFIG_FILE}."
        echo -n "" > "${CONFIG_FILE}"
        RUNTYPE="edit"
    else
        _report -d "Reset aborted. Exiting."
        exit 0
    fi
fi
while [[ "${RUNTYPE}" = "edit" || "${RUNTYPE}" = "GUI" ]] ; do
    _edit_mode
done

_review_option(){
    unset NO_LOOKUP
    OPTIND=1
    while getopts "n" opt ; do
        case "${opt}" in
            n) NO_LOOKUP="Y" #also the SELECTED value to be used as-is rather than lookup what it means
        esac
    done
    shift "$((OPTIND-1))"
    VALUE_NAME="${1}"
    SELECTED="${!1}"
    shift
    CHOICES=("${@}")
    if [[ ! " ${CHOICES[@]} " =~ " ${SELECTED} " ]] ; then
        _report -w "The configuration file uses an invalid value of ${SELECTED} for ${VALUE_NAME}. Valid values are: ${CHOICES[*]}. Please restart ${SCRIPTNAME} in edit mode (${SCRIPTNAME} -e) or update the configuration file at ${CONFIG_FILE}."
        exit 2
    fi
    if [[ "${SELECTED}" ]] ; then
        if [[ "${NO_LOOKUP}" != "Y" ]] ; then
          _lookup_choice "${SELECTED}"
        fi
    else
        _report -w "The option for ${VALUE_NAME} is not set. Please restart ${SCRIPTNAME} in edit mode (${SCRIPTNAME} -e) or update the configuration file at ${CONFIG_FILE}."
        exit 3
    fi
    LOG_OF_OPTIONS+="${VALUE_NAME}: ${SELECTED}\n"
}

_review_all_options(){
    if [[ "${INVERT_PHASE}" = 'true' ]] ; then
        PHASE_VALUE="-1*"
    fi
    if [[ "${DEVICE_INPUT_CHOICE}" = "0" ]] ; then
        _review_option -n "DECKLINK_UTILITY_CHOICE" "${DECKLINK_UTILITIES[@]}"
        _review_option "VIDEO_INPUT_CHOICE" "${VIDEO_INPUT_OPTIONS[@]}"
        _review_option "AUDIO_INPUT_CHOICE" "${AUDIO_INPUT_OPTIONS[@]}"
        _review_option "VIDEO_BIT_DEPTH_CHOICE" "${VIDEO_BITDEPTH_OPTIONS[@]}"
        _review_option "AUDIO_MAPPING_CHOICE" "${CHANNEL_MAPPING_OPTIONS[@]}"
        if [[ -z "${ALT_INPUT}" ]] ; then
            _review_option "TIMECODE_CHOICE" "${TIMECODE_OPTIONS[@]}"
        fi
        _review_option "STANDARD_CHOICE" "${STANDARD_OPTIONS[@]}"
    elif [[ "${DEVICE_INPUT_CHOICE}" = "1" ]] ; then
        _review_option -n "AVFCTL_INPUT_CHOICE" "${AVFCTL_DEVICES[@]}"
    elif [[ "${DEVICE_INPUT_CHOICE}" = "2" ]] ; then
        _review_option -n "AUDIO_DEV_CHOICE" "${AUDIO_DEVICES[@]}"
    fi
    if [[ "${CORE_COUNT}" -le 2 && "${RUNTYPE}" = "record" ]] ; then
        _report -w "Since this computer has only ${CORE_COUNT} cores, the playback will display only half of the frames to reduce CPU. This will not impact the recording."
        PLAYBACK_FILTER_ADJUSTMENT="select=not(mod(n\,2)),"
    fi
    if [[ "${RUNTYPE}" = "passthrough" ]] && [[ -n "${PLAYBACKVIEW_CHOICE_PASS}" ]] && [[ "${PLAYBACKVIEW_CHOICE_PASS}" != "Unselected" ]] ; then
        _review_option "PLAYBACKVIEW_CHOICE_PASS" "${PLAYBACKVIEW_PASS_OPTIONS[@]}"
    else
        _review_option "PLAYBACKVIEW_CHOICE" "${PLAYBACKVIEW_OPTIONS[@]}"
    fi
    if [[ "${DEVICE_INPUT_CHOICE}" = 0 ]] ; then
        if [[ "${PLAYBACKVIEW_CHOICE}" = "Full Range Visual" ]] ; then
            MIDDLEOPTIONS+=(-color_range jpeg)
        else
            MIDDLEOPTIONS+=(-color_range mpeg)
        fi
        MIDDLEOPTIONS+=(-metadata creation_time=now)
        MIDDLEOPTIONS+=(${EXTRAOUTPUTOPTIONS[@]})
    elif [[ "${DEVICE_INPUT_CHOICE}" = "1" ]] ; then
        PLAYBACKVIEW_CHOICE_PASS="Unfiltered"
        PLAYBACKVIEW_CHOICE="Unfiltered"
        _lookup_choice "Unfiltered"
    elif [[ "${DEVICE_INPUT_CHOICE}" = "2" ]] ; then
        _review_option "AUDIO_CHANNEL_CHOICE" "${AUDIO_CHANNEL_CHOICE_OPTIONS[@]}"
        _review_option "AUDIO_MODE_SR_CHOICE" "${AUDIO_MODE_SR_CHOICE_OPTIONS[@]}"
        PLAYBACKVIEW_CHOICE_PASS="Audio"
        PLAYBACKVIEW_CHOICE="Audio"
        _lookup_choice "Audio"
    fi
}

_review_all_options

# CLI passthrough and audiopassthrough modes
# GUI mode loops
if [[ "${GUI}" = 1 ]] ; then
    while [[ "${RUNTYPE}" != "record" ]] ; do
        if [[ "${RUNTYPE}" = "passthrough" ]] ; then
            _passthrough_mode
            RUNTYPE="GUI"
        elif [[ "${RUNTYPE}" = "audiopassthrough" ]] ; then
            _audiopassthrough_mode
            RUNTYPE="GUI"
        elif [[ "${RUNTYPE}" = "edit" || "$RUNTYPE" = "GUI" ]] ; then
            _edit_mode
        fi
    done
else
    if [[ "${RUNTYPE}" = "passthrough" ]] ; then
        _passthrough_mode
        exit 0
    elif [[ "${RUNTYPE}" = "audiopassthrough" ]] ; then
        _audiopassthrough_mode
        exit 0
    fi
fi

# record mode
while [[ -z "${ID}" ]] ; do
    _report -q -n "Enter ${AHEM}Identifier: "
    read ID
    if [[ "${ID}" = "q" ]] ; then
        _report -w "Interpreting 'q' to quit."
        exit 1
    fi
    AHEM="a (non-blank) "
done
if [[ ! -d "${DIR}" ]] ; then
    _report -q -n "Enter Directory: "
    read DIR
    DIR="$(echo "${DIR}" | sed "s/^['\"]\(.*\).$/\1/")"
    if [[ ! -d "${DIR}" ]] ; then
        _report -w "Error: Not a valid directory"
        exit 1
    fi
fi

if [[ ! -d "${LOGDIR}" ]] ; then
    if [[ ! -d "${DIR}" ]] ; then
        _report -q -n "Enter Directory for Auxiliary Files (If blank will default to recording directory): "
        read LOGDIR
        LOGDIR="$(echo "${LOGDIR}" | sed "s/^['\"]\(.*\).$/\1/")"
    else
        LOGDIR="${DIR}"
    fi
    if [[ ! -d "${LOGDIR}" ]] ; then
        _report -w "Error: Not a valid directory"
        exit 1
    fi
fi

if [[ "${DEVICE_INPUT_CHOICE}" = "0" ]] ; then
    _review_option "CONTAINER_CHOICE" "${CONTAINER_OPTIONS[@]}"
    _review_option "VIDEO_CODEC_CHOICE" "${VIDEO_CODEC_OPTIONS[@]}"
    if [[ "${VIDEO_CODEC_CHOICE}" = "FFV1 version 3" ]] ; then
        _review_option -n "FFV1_SLICE_CHOICE" "${FFV1_SLICE_OPTIONS[@]}"
    fi
    _review_option "AUDIO_CODEC_CHOICE" "${AUDIO_CODEC_OPTIONS[@]}"
elif [[ "${DEVICE_INPUT_CHOICE}" = "1" ]] ; then
    EXTENSION="dv"
    FORMAT="rawvideo"
elif [[ "${DEVICE_INPUT_CHOICE}" = "2" ]] ; then
    _review_option "AUDIO_MODE_CODEC_CHOICE" "${AUDIO_CODEC_OPTIONS[@]}"
    EXTENSION="${AUDIO_EXT}"
    FORMAT="${AUDIO_EXT}"
fi

# Check for user suffix to override automatic settings
if [[ "${NO_SUFFIX}" = 'true' ]] ; then
    SUFFIX=""
elif [[ -n "${USER_SUFFIX}" ]] ; then
    SUFFIX="${USER_SUFFIX}"
fi

FULL_OUTPUT_ID="${PREFIX}${ID}${SUFFIX}"
FULL_CAPTURE_LOG="${LOGDIR}/${FULL_OUTPUT_ID}${CAPTURELOGSUFFIX}"

VRECORD_OUTPUT="${DIR}/${FULL_OUTPUT_ID}.${EXTENSION}"
if [[ -f "${VRECORD_OUTPUT}" ]] ; then
    _report -w "A file called ${VRECORD_OUTPUT} already exists."
    _report -w "Exiting to avoid overwriting that file."
    exit
fi

if [[ "${DEVICE_INPUT_CHOICE}" = "0" ]] ; then
    _review_option "QCTOOLSXML_CHOICE" "${QCTOOLSXML_OPTIONS[@]}"
    if [[ "${QCTOOLSXML_CHOICE}" != "No" && ! "$(command -v qcli)" ]] ; then
        _report -w "Please install qcli to use the qctools reporting option."
        _report -w "Such as \`brew install qcli\`."
        exit 1
    fi
    _review_option "FRAMEMD5_CHOICE" "${FRAMEMD5_OPTIONS[@]}"
    if [[ "${FRAMEMD5_CHOICE}" = "Yes" ]] ; then
        FRAMEMD5NAME="${LOGDIR}/${FULL_OUTPUT_ID}.framemd5"
        EXTRAOUTPUTS=(-an -f framemd5 "${FRAMEMD5NAME}")
    fi
    if [[ "${FORMAT}" = "matroska" ]] ; then
        _review_option "EMBED_LOGS_CHOICE" "${EMBED_LOGS_OPTIONS[@]}"
    fi
fi

if [[ -n "${DURATION}" ]] ; then
    DUR_SECONDS=$(bc <<< "${DURATION} * 60" | sed "s/^\./0./")
    TIME_LIMIT=(-t "${DUR_SECONDS}")
fi

if [[ "${DEVICE_INPUT_CHOICE}" = "0" ]] ; then
    _report -d "Summary: ${VIDEOCODECNAME}/${FORMAT} ${PIXEL_FORMAT} file from ${STANDARD} ${VIDEO_INPUT} ${AUDIO_INPUT}. Frame MD5s=${FRAMEMD5_CHOICE}, QCTools XML=${QCTOOLSXML_CHOICE}, and Technician=${TECHNICIAN}. Inputs recorded to ${VRECORD_OUTPUT} and Auxiliary Files created in ${LOGDIR}"
elif [[ "${DEVICE_INPUT_CHOICE}" = "1" ]] ; then
    _report -d "Summary: Copying video from ${AVFCTL_INPUT_CHOICE}. Technician=${TECHNICIAN}. Inputs recorded to ${VRECORD_OUTPUT} and Auxiliary Files created in ${LOGDIR}"
elif [[ "${DEVICE_INPUT_CHOICE}" = "2" ]] ; then
    _report -d "Summary: Recording audio from ${AUDIO_DEV_CHOICE}. Technician=${TECHNICIAN}. Inputs recorded to ${VRECORD_OUTPUT} and Auxiliary Files created in ${LOGDIR}"

fi

if [[ "${DEVICE_INPUT_CHOICE}" = "0" ]] ; then
    if [[ "${INVERT_PHASE}" = 'true' ]] ; then
        echo -e " \033[101mWARNING: Option to invert phase of second audio channel has been selected\033[0m"
    fi
fi
_report -q "Hit enter to start recording"
read

# create log of vrecord decisions
INGESTLOG="${LOGDIR}/${FULL_OUTPUT_ID}_capture_options.log"
QCXML="${LOGDIR}/${FULL_OUTPUT_ID}.${EXTENSION}.qctools.xml.gz"
QCLI_COMMAND_PIPE=(qcli -f signalstats+aphasemeter+astats+ssim -i - -o "${QCXML}")
QCLI_COMMAND_FILE=(qcli -f signalstats+aphasemeter+astats+ssim -i "${VRECORD_OUTPUT}" -o "${QCXML}")
touch "${INGESTLOG}"
_writeingestlog "computer_name" "$(uname -n)"
_writeingestlog "computer_model_name" "${COMPUTER_MODEL_NAME}"
if [[ "${OS_TYPE}" = "macOS" ]] ; then
    _writeingestlog "computer_model_id" "${COMPUTER_MODEL_ID}"
    _writeingestlog "computer_processor_name" "${COMPUTER_PROCESSOR_NAME}"
    _writeingestlog "computer_processor_speed" "${COMPUTER_PROCESSOR_SPEED}"
    _writeingestlog "computer_processor_count" "${COMPUTER_PROCESSOR_COUNT}"
    _writeingestlog "computer_memory" "${COMPUTER_MEMORY}"
    _writeingestlog "computer_serial" "${COMPUTER_SERIAL}"
fi
_writeingestlog "computer_cores" "$CORE_COUNT"
_writeingestlog "user_name" "$(whoami)"
_writeingestlog "operating_system_VERSION" "$(uname -v)"
_writeingestlog "vrecord version" "${VERSION}"
_writeingestlog "datetime_start" "$(_get_iso8601)"

MOUNT_PATH="$(df -Ph "${DIR}" | tail -n 1 | awk '{print $6}')"
if [[ "${OS_TYPE}" = "macOS" ]] ; then
    VOLUME_INFO="$(diskutil info "${MOUNT_PATH}")"
    PART_OF_WHOLE="/dev/$(_parse_report "Part of Whole" "${VOLUME_INFO}")"
    CAPTURE_DEVICE_INFO="$(diskutil info "${PART_OF_WHOLE}")"

    _writeingestlog "capture_device_node" "$(_parse_report "Device Node" "${CAPTURE_DEVICE_INFO}")"
    _writeingestlog "capture_device_protocol" "$(_parse_report "Protocol" "${CAPTURE_DEVICE_INFO}")"
    _writeingestlog "capture_device_name" "$(_parse_report "Device / Media Name" "${CAPTURE_DEVICE_INFO}")"
    _writeingestlog "capture_device_block_size" "$(_parse_report "Device Block Size" "${CAPTURE_DEVICE_INFO}")"
    _writeingestlog "capture_device_location" "$(_parse_report "Device Location" "${CAPTURE_DEVICE_INFO}")"
    _writeingestlog "capture_device_partition_type" "$(_parse_report "Partition Type" "${VOLUME_INFO}")"
    _writeingestlog "capture_device_partition_name" "$(_parse_report "Name (User Visible)" "${VOLUME_INFO}")"
    _writeingestlog "capture_device_volume_uuid" "$(_parse_report "Volume UUID" "${VOLUME_INFO}")"
    _writeingestlog "capture_device_volume_available" "$(_parse_report "Volume Available Space" "${VOLUME_INFO}")"
    _writeingestlog "capture_device_volume_total" "$(_parse_report "Volume Total Space" "${VOLUME_INFO}")"
fi

_writeingestlog "FILE_PATH" "${VRECORD_OUTPUT}"

if [[ "${DEVICE_INPUT_CHOICE}" = 0 ]] ; then
    if [[ -n "${VIDEO_CARD_DRIVER_VERSION}" ]] ; then
        _writeingestlog "video_card_driver_version" "${VIDEO_CARD_DRIVER_VERSION}"
    fi
    _writeingestlog "video_card_name" "${DECKLINK_INPUT_CHOICE}"
fi

echo -e "${LOG_OF_OPTIONS}" >> "${INGESTLOG}"
if [[ -n "${TECHNICIAN}" ]] ; then
    _writeingestlog "TECHNICIAN" "${TECHNICIAN}"
fi
if [[ "${INVERT_PHASE}" = 1 ]] ; then
    _writeingestlog "INVERT_PHASE" "Yes"
fi
if [[ -n "${EXTRAINPUTOPTIONS[@]}" ]] ; then
    _writeingestlog "EXTRA_INPUT_OPTIONS" "${EXTRAINPUTOPTIONS[@]}"
fi
if [[ -n "${EXTRAOUTPUTOPTIONS[@]}" ]] ; then
    _writeingestlog "EXTRA_OUTPUT_OPTIONS" "${EXTRAOUTPUTOPTIONS[@]}"
fi

_report -d "Close the playback window to stop recording."

# vrecord process!
_setup_vrecord_process
if [[ "${VRECORD_STEPS}" = "2" ]] ; then
    _writeingestlog "Capture-Record command" "${RECORD_COMMAND[@]}"
    _writeingestlog "Playback command" "${PLAYER_COMMAND[@]}"
    "${RECORD_COMMAND[@]}" 2> >(tee "${VRECORD_INPUT_TMP}" 1>&2) | \
    if [[ "${DEVICE_INPUT_CHOICE}" = 0 ]] && [[ "${QCTOOLSXML_CHOICE}" = "Yes, concurrent with recording" ]]; then
        tee >("${PLAYER_COMMAND[@]}") | "${QCLI_COMMAND_PIPE[@]}"
    else
        "${PLAYER_COMMAND[@]}"
    fi
elif [[ "${VRECORD_STEPS}" = "3" ]] ; then
    _writeingestlog "Capture command" "${RECORD_COMMAND[@]}"
    _writeingestlog "Record command" "${FF_RECORD_COMMAND[@]}"
    _writeingestlog "Playback command" "${PLAYER_COMMAND[@]}"
    "${RECORD_COMMAND[@]}" 2> >(tee "${VRECORD_INPUT_TMP}" 1>&2) | \
    "${FF_RECORD_COMMAND[@]}" 2> >(tee "${VRECORD_INPUT_TMP}" 1>&2) | \
    if [[ "${DEVICE_INPUT_CHOICE}" = 0 ]] && [[ "${QCTOOLSXML_CHOICE}" = "Yes, concurrent with recording" ]]; then
        tee >("${PLAYER_COMMAND[@]}") | "${QCLI_COMMAND_PIPE[@]}"
    else
        "${PLAYER_COMMAND[@]}"
    fi
else
    _report_unexpected_error VRECORD_STEPS
fi
# capture errors from components of recording pipe
RESULTING_EXIT_CODES=("${PIPESTATUS[@]}")
P1_ERR="${RESULTING_EXIT_CODES[0]}"
P2_ERR="${RESULTING_EXIT_CODES[1]}"
P3_ERR="${RESULTING_EXIT_CODES[2]}"

if [[ "${VRECORD_STEPS}" = "2" ]] ; then
    _writeingestlog "Capture-Record exit code" "${P1_ERR}"
    _writeingestlog "Playback exit code" "${P2_ERR}"
elif [[ "${VRECORD_STEPS}" = "3" ]] ; then
    _writeingestlog "Capture exit code" "${P1_ERR}"
    _writeingestlog "Record exit code" "${P2_ERR}"
    _writeingestlog "Playback exit code" "${P3_ERR}"
fi

if [[ ! -s "${VRECORD_OUTPUT}" ]] ; then
    if [[ "$P1_ERR" != "0" ]] ; then
        _report_unexpected_error P1_ERR "${RECORD_COMMAND[@]} // ${FF_RECORD_COMMAND[@]} // ${PLAYER_COMMAND}"
    fi
    if [[ "$P2_ERR" != "0" && ! -z "$P2_ERR" ]] ; then
        _report_unexpected_error P2_ERR "${RECORD_COMMAND[@]} // ${FF_RECORD_COMMAND[@]} // ${PLAYER_COMMAND}"
    fi
    if [[ "$P3_ERR" != "0" && ! -z "$P3_ERR" ]] ; then
        _report_unexpected_error P3_ERR "${RECORD_COMMAND[@]} // ${FF_RECORD_COMMAND[@]} // ${PLAYER_COMMAND}"
    fi
fi

mv "${VRECORD_INPUT_TMP}" "${FULL_CAPTURE_LOG}"
_writeingestlog "datetime_end" "$(_get_iso8601)"
trap _cleanup SIGHUP SIGINT SIGTERM

if [[ "${DEVICE_INPUT_CHOICE}" = 0 ]] ; then
    # timecode document handling
    if [[ -f "${TC_TMP}" ]] ; then
        mv "${TC_TMP}" "${LOGDIR}/${FULL_OUTPUT_ID}_${TC_TYPE}${TIMECODELOGSUFFIX}"
    fi

    # qc tools process
    if [[ "${QCTOOLSXML_CHOICE}" = "Yes, after recording" ]] ; then
        "${QCLI_COMMAND_FILE[@]}"
    fi
    if [[ "${QCTOOLSXML_CHOICE}" != "No" ]] ; then
        _report -d "Vrecord is analyzing your video file. Please be patient."
        if [[ -s "${QCXML}" ]] ; then
            if [[ "${PIXEL_FORMAT}" = "yuv422p10" ]] ; then
                SAT_OUTLIERS=$("${ZCAT_COMMAND}" "${QCXML}" | perl -nle 'print if not m{lavfi.(?!signalstats.SATMAX)}' | xmlstarlet sel -t -v "count(//tag[@key='lavfi.signalstats.SATMAX'][@value>496])" -n)
            elif [[ "${PIXEL_FORMAT}" = "uyvy422" ]] ; then
                SAT_OUTLIERS=$("${ZCAT_COMMAND}" "${QCXML}" | perl -nle 'print if not m{lavfi.(?!signalstats.SATMAX)}' | xmlstarlet sel -t -v "count(//tag[@key='lavfi.signalstats.SATMAX'][@value>124])" -n)
            fi
            AUD_OUTLIERS=$("${ZCAT_COMMAND}" "${QCXML}" | perl -nle 'print if not m{lavfi.(?!astats.Overall.Peak_level)}' | grep -v "tag key=\"lavfi.[^a]" | xmlstarlet sel -t -v "count(//tag[@key='lavfi.astats.Overall.Peak_level'][@value>=-0.01])" -n)
            BRNG_OUTLIERS=$("${ZCAT_COMMAND}" "${QCXML}" | perl -nle 'print if not m{lavfi.(?!signalstats.BRNG)}' | xmlstarlet sel -t -v "count(//tag[@key='lavfi.signalstats.BRNG'][@value>=0.03])" -n)
            AUDIO_PEAK=$("${ZCAT_COMMAND}" "${QCXML}" | grep lavfi.astats.Overall.Peak_level | cut -d '"' -f 4 | sort -n | tail -n 1)
            _writeingestlog "Peak Volume is (dB)" "${AUDIO_PEAK}"
            if "$GNUPLOT_INSTALLED" && "$QCLI_INSTALLED" ; then
                _report -d "Vrecord is generating graphs from the QCTools data. One moment please."
                _qcgraphimage "${QCXML}"
            fi
        else
            _report -w "qctools XML ${QCXML} is empty or does not exist!"
        fi
        if [[ "${SAT_OUTLIERS}" -gt "${SAT_OUTLIER_THRSHLD}" ]] ; then
            cowsay "$(_report -w "WARNING: Your video file contains ${SAT_OUTLIERS} frames with illegal saturation values. Your deck may require cleaning.")"
        fi
        if [[ "${AUD_OUTLIERS}" -gt "${AUD_OUTLIER_THRSHLD}" ]] ; then
            cowsay "$(_report -w "WARNING: Your video file contains ${AUD_OUTLIERS} frames with clipped audio levels.")"
        fi
        if [[ "${BRNG_OUTLIERS}" -gt "${BRNG_OUTLIER_THRSHLD}" ]] ; then
            cowsay "$(_report -w "WARNING: Your video file contains ${BRNG_OUTLIERS} frames with pixels out of broadcast range.")"
        fi
        _report -d "QCTools analysis is complete."
    fi

    # check for discontinuities in the Frame MD5s; if user chose not to use Frame MD5s, check for frame discontinuties in the FFmpeg file
    if [[ "${FRAMEMD5_CHOICE}" = "Yes" ]] ; then
        PTS_DISCONTINUITY=$(cat "${FRAMEMD5NAME}" | grep -v "^#" | cut -d, -f3 | sed 's/ //g' | grep -v "^0$" | awk '{if($1!=p+1){if(p+1==$1-1){printf p+1" "}else{printf p+1"-"$1-1" "}}{p=$1}}')
        if [[ -z "${PTS_DISCONTINUITY}" ]] ; then
            _writeingestlog "PTS_DISCONTINUITY" "none"
        else
            _writeingestlog "PTS_DISCONTINUITY" "${PTS_DISCONTINUITY}"
            cowsay "$(_report -w "WARNING: There were presentation timestamp discontinuities in the file's frame MD5s for these frame ranges: ${PTS_DISCONTINUITY}. This error may indicate frames dropped by FFmpeg or vrecord. The file may have sync issues.")"
        fi
    elif [[ "${FRAMEMD5_CHOICE}" = "No" ]] ; then
        FRAMES_ENCODED=$(cat "${LOGDIR}/${FULL_OUTPUT_ID}"_ffmpeg_input.log | grep -w "frames encoded" | awk '{print $10}' | grep -m 1 [0-9])
        FRAMES_DECODED=$(cat "${LOGDIR}/${FULL_OUTPUT_ID}"_ffmpeg_input.log | grep -w "frames decoded" | awk '{print $10}' | grep -m 1 [0-9])
        if [[ "${FRAMES_ENCODED}" -lt $((FRAMES_DECODED-1)) ]] ; then
            FRAMES_DISCREPANCY=$((FRAMES_DECODED-FRAMES_ENCODED))
            cowsay "$(_report -w "WARNING: There were presentation timestamp discontinuities found in the framemd5s. This error may indicate frames dropped by FFmpeg or vrecord. The file may have sync issues.")"
            _writeingestlog "ffmpeg_missing_frames" "${FRAMES_DISCREPANCY}"
        else
            _writeingestlog "ffmpeg_missing_frames" "None"
        fi
    fi

    # check for frames dropped in ffmpeg_input.log
    DROPPED_FRAMES_INSTANCES=$(grep -c "Frames dropped" "${FULL_CAPTURE_LOG}")
    DROPPED_FRAMES_FRAMENUMBERS=$(grep "Frames dropped" "${FULL_CAPTURE_LOG}" | awk '{print $6}' | sed 's/[(#)]//g')
    if [[ "${DROPPED_FRAMES_INSTANCES}" -gt 0 ]] ; then
        cowsay "$(_report -w "WARNING: FFmpeg Decklink input reported dropped frames in the following ${DROPPED_FRAMES_INSTANCES} locations. This error may indicate an interrupted signal between hardware components. The file may be missing content. With decklink inputs, this cow recommends reviewing your settings in Desktop Video Setup and setting the video and audio inputs to match what those set in vrecord.")"
        for i in ${DROPPED_FRAMES_FRAMENUMBERS} ; do # do not quote this variable
            DROPPED_FRAMES_TIMESTAMPS+="$(_frames_to_hhmmss "${i}") "
        done
        _report -w "Dropped frames timestamps: ${DROPPED_FRAMES_TIMESTAMPS}"
        _writeingestlog "DROPPED_FRAMES_TIMESTAMPS" "${DROPPED_FRAMES_TIMESTAMPS}"
    fi

    # check for input buffer overrun error
    BUFFER_OVERRUN=$(grep -c "Decklink input buffer overrun" "${FULL_CAPTURE_LOG}")
    if [[ "${BUFFER_OVERRUN}" -gt 0 ]] ; then
        cowsay "$(_report -w "WARNING: FFmpeg Decklink input reported a buffer overrun. The file is likely missing frames or contains artifacts from the buffer overrun.")"
        _writeingestlog "Decklink input buffer overrun" "Yes"
    fi

    # policy checks with mediaconch
    if "$MEDIACONCH_INSTALLED" ; then
        if [[ "${VIDEO_CODEC_CHOICE}" = "Uncompressed Video" ]] ; then
            _report -d "Checking file conformance against uncompressed video policy..."
            STATUS=$(mediaconch -fx -p "${RESOURCE_PATH}/vrecord_policy_uncompressed.xml" "${VRECORD_OUTPUT}" | xmlstarlet sel -N mc="https://mediaarea.net/mediaconch" -t -v mc:MediaConch/mc:media/mc:policy/@outcome -n)
            if [[ "$STATUS" = "pass" ]] ; then
                _report -dt "File passed policy check for uncompressed video."
            elif [[ "$STATUS" = "fail" ]] ; then
                _report -wt "File did not pass vrecord policy check for uncompressed video and may not conform to digital preservation standards. Try another file?"
                mediaconch -fx -p "${RESOURCE_PATH}/vrecord_policy_uncompressed.xml" "${VRECORD_OUTPUT}" | xmlstarlet fo > "${DIR}/${FULL_OUTPUT_ID}_mediaconchreport.xml"
                _report -wt "See ${DIR}/${ID}${SUFFIX}_mediaconchreport.xml for a full MediaConch policy report."
            else
                mediaconch -p "${RESOURCE_PATH}/vrecord_policy_uncompressed.xml" "${VRECORD_OUTPUT}"
            fi
        elif [[ "${VIDEO_CODEC_CHOICE}" = "FFV1 version 3" ]] ; then
            _report -d "Checking file conformance against FFV1 video policy..."
            STATUS=$(mediaconch -fx -p "${RESOURCE_PATH}/vrecord_policy_ffv1.xml" "${VRECORD_OUTPUT}" | xmlstarlet sel -N mc="https://mediaarea.net/mediaconch" -t -v mc:MediaConch/mc:media/mc:policy/@outcome -n)
            if [[ "${STATUS}" = "pass" ]] ; then
                _report -dt "File passed policy check for FFV1 video."
            elif [[ "$STATUS" = "fail" ]] ; then
                _report -wt "File did not pass vrecord policy check for FFV1 video and may not conform to digital preservation standards. Try another file?"
                mediaconch -fx -p "${RESOURCE_PATH}/vrecord_policy_ffv1.xml" "${VRECORD_OUTPUT}" | xmlstarlet fo > "${DIR}/${FULL_OUTPUT_ID}_mediaconchreport.xml"
                _report -wt "See ${DIR}/${ID}${SUFFIX}_mediaconchreport.xml for a full MediaConch policy report."
            else
                mediaconch -p "${RESOURCE_PATH}/vrecord_policy_ffv1.xml" "${VRECORD_OUTPUT}"
            fi
        fi
    fi

    # embed logs in Matroska files
    if "$MKVPROPEDIT_INSTALLED" ; then
        if [[ "${CONTAINER_CHOICE}" = "Matroska" ]] && [[ "${EMBED_LOGS_CHOICE}" = "Yes" ]] ; then
            _report -d "Vrecord is attaching logs to your Matroska file:"
            mkvpropedit "${VRECORD_OUTPUT}" --attachment-description "Capture options selected by user during vrecord process" --add-attachment "${INGESTLOG}"
            mkvpropedit "${VRECORD_OUTPUT}" --attachment-description "Full FFmpeg output from vrecord capture process" --add-attachment "${FULL_CAPTURE_LOG}"
            if [[ "${QCTOOLSXML_CHOICE}" = "Yes" ]] ; then
                mkvpropedit "${VRECORD_OUTPUT}" --attachment-description "QCTools report from vrecord capture process (zipped XML)" --add-attachment "${QCXML}"
            fi
            _report -d "Vrecord is done attaching logs to your Matroska file!"
        fi
    fi
fi
