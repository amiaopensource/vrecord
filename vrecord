#!/usr/bin/env bash

# vrecord
# Open-source software for capturing a video signal and turning it into a digital file.

SCRIPTNAME=$(basename "${0}")
SCRIPTDIR=$(dirname "${0}")
CONFIG_FILE="${HOME}/.${SCRIPTNAME}.conf"
unset VERSION
if [[ $(dirname "$(command -v "${0}")") = "/usr/local/bin" ]] ; then
    VERSION=$(TMP=$(brew info vrecord | grep ".*\*$" | grep -Eo "/vrecord/.* \(") ; echo "${TMP:9:(${#TMP}-11)}")
    RESOURCE_PATH="$(brew --prefix vrecord)"
else
    RESOURCE_PATH="${SCRIPTDIR}/Resources"
fi

unset INPUTOPTIONS
unset MIDDLEOPTIONS
unset SUFFIX
unset DURATION
unset TECHNICIAN
RUNTYPE="record"
CAPTURELOGSUFFIX="_ffmpeg_input.log"
TIMECODELOGSUFFIX="_frame_timecodes.txt"
unset EXTRAOUTPUTS
SAT_OUTLIER_THRSHLD=14
AUD_OUTLIER_THRSHLD=10
BRNG_OUTLIER_THRSHLD=14
if [[ -d "/usr/local/opt/ffmpegdecklink" ]] ; then
    BREW_PREFIX="/usr/local/opt/ffmpegdecklink"
elif [[ -d "/home/linuxbrew/.linuxbrew/opt/ffmpegdecklink" ]] ; then
    BREW_PREFIX="/home/linuxbrew/.linuxbrew/opt/ffmpegdecklink"
else
    BREW_PREFIX="$(brew --prefix ffmpegdecklink 2>/dev/null)"
fi
if [[ -d "${BREW_PREFIX}/bin" ]] ; then
    FFMPEG_BIN="${BREW_PREFIX}/bin/ffmpeg-dl"
    FFPLAY_BIN="${BREW_PREFIX}/bin/ffplay-dl"
    FFPROBE_BIN="${BREW_PREFIX}/bin/ffprobe-dl"
else
    FFMPEG_BIN="$(which ffmpeg)"
    FFPLAY_BIN="$(which ffplay)"
    FFPROBE_BIN="$(which ffprobe)"
fi
MPVOPTS=(--no-osc)
MPVOPTS+=(--load-scripts=no)
MPVOPTS+=(--script="${RESOURCE_PATH}/qcview.lua")
MPVOPTS+=(--really-quiet)

if [[ "$("${FFMPEG_BIN}" -version 2>&1 | grep "Library not loaded" >/dev/null)" || ! -f "${FFMPEG_BIN}" || ! -f "${FFPLAY_BIN}" ]] ; then
    echo "Please reinstall 'ffmpegdecklink':"
    echo "  brew reinstall amiaopensource/amiaos/ffmpegdecklink"
    echo "Or install a version of ffmpeg that is compiled with decklink support if you wish to use that input."
    echo "Exiting."
    exit 1
fi

_usage(){
    cat <<EOF
${SCRIPTNAME} ${VERSION}

${SCRIPTNAME} will record a file via ffmpeg and the the Blackmagic SDK or
AVFoundation. It is an interactive script and will create 10 or 8-bit video
files.

Dependencies: cowsay, amiaopensource/amiaos/decklinksdk,
  amiaopensource/amiaos/ffmpegdecklink, amiaopensource/amiaos/gtkdialog,
  freetype, sdl and xmlstarlet
Optional Dependencies: gnuplot, mediaconch, mkvtoolnix, mpv, qcli

Usage: ${SCRIPTNAME} [ -g | -e | -r | -p | -a | -x | -v | -h ]
  -g  use the GUI
  -e  edit the configuration file before recording
  -r  enable record mode [default]
  -p  enable passthrough mode where the video signal coming into the
      computer can be monitored, but not written to a file. Useful for
      testing equipment and setting up a tape to bars.
  -a  enable audio passthrough mode. Identical to passthrough except for
      the addition of audio bars. Note: Will eventually lag and crash if
      left on too long.
  -x  reset the configuration: this will replace the default configuration
      file at '${CONFIG_FILE}' with an empty one.
  -v  Run ffmpeg with '-loglevel debug'. Using this option creates a very
      large log file, so avoid using this option with 'Visual + Numerical'
      or any playback option that display the log as part of the view.
  -h  display this help menu

Advanced options
  -I  Provide a string of input options for the recording ffmpeg to use.
      For example "vrecord -I '-loglevel trace'" would force an ffmpeg
      logging level that is usually unaccessible via vrecord preferences.
  -O  Provide a string of output options for the recording ffmpeg to use.
  -i  Provide a file as an input to vrecord, rather than using the
      decklink device. For testing without a decklink device.

See also the man page: man ${SCRIPTNAME}
EOF
}

# local functions
_get_iso8601(){
    date +%FT%T
}

_maketemp(){
    if [[ "${1}" ]] ; then
        EXT="${1}"
    else
        EXT=""
    fi
    echo "$(mktemp -q "/tmp/$(basename "${0}").XXXXXX")${EXT}"
}
VRECORD_INPUT_TMP="$(_maketemp .vrecord_input.log)"

_report(){
    local RED="$(tput setaf 1)"    # Red      - For Warnings
    local GREEN="$(tput setaf 2)"  # Green    - For Declarations
    local BLUE="$(tput setaf 4)"   # Blue     - For Questions
    local NC="$(tput sgr0)"        # No Color
    local COLOR=""
    local STARTMESSAGE=""
    local ECHOOPT=""
    OPTIND=1
    while getopts "qdwstn" opt ; do
        case "${opt}" in
            q) COLOR="${BLUE}" ;;                        # question mode, use color blue
            d) COLOR="${GREEN}" ;;                       # declaration mode, use color green
            w) COLOR="${RED}" ;;                         # warning mode, use color red
            s) STARTMESSAGE+=([${SCRIPTNAME}] ) ;;       # prepend scriptname to the message
            t) STARTMESSAGE+=($(_get_iso8601) '- ' ) ;;  # prepend timestamp to the message
            n) ECHOOPT="-n" ;;                           # to avoid line breaks after echo
        esac
    done
    shift "$((OPTIND-1))"
    MESSAGE="${1}"
    echo ${ECHOOPT} "${COLOR}${STARTMESSAGE[@]}${MESSAGE}${NC}"
}

_parse_report(){
    KEY="${1}"
    REPORT="${2}"
    echo "${REPORT}" | grep -i "^[ ]*${KEY}:" | cut -d : -f 2- | awk '{$1=$1;print}'
}

_cleanup(){
    _report -wt "Vrecord is being stopped at $(_get_iso8601), noting this in the capture log."
    _writeingestlog "exit status" "vrecord was forced to quit early at $(_get_iso8601). Some processing may be incomplete."
}

_check_mpv(){
    if ! mpv > /dev/null ; then
        mpv
        _report -wt "mpv doesn't appear to be running correctly. Try 'brew reinstall mpv'."
        exit 1
    fi
}

# Set variables for system differences
QUERY_OS_TYPE="$(uname -s)"
if [[ "${QUERY_OS_TYPE}" = "Darwin" ]] ; then
    OS_TYPE="macOS"
    if [[ -f "/Library/Fonts/Andale Mono.ttf" ]] ; then
      DEFAULTFONT="/Library/Fonts/Andale Mono.ttf"
    elif [[ -f "/System/Library/Fonts/Supplemental/Andale Mono.ttf" ]] ; then
      DEFAULTFONT="/System/Library/Fonts/Supplemental/Andale Mono.ttf"
    elif [[ -f "/System/Library/Fonts/Monaco.dfont" ]] ; then
      DEFAULTFONT="/System/Library/Fonts/Monaco.dfont"
    elif [[ -f "/Library/Fonts/Microsoft/Lucida Console.ttf" ]] ; then
      DEFAULTFONT="/Library/Fonts/Microsoft/Lucida\Console.ttf"
    elif [[ -f "/Library/Fonts/LetterGothicStd.otf" ]] ; then
      DEFAULTFONT="/Library/Fonts/LetterGothicStd.otf"
    else
      _report -wt "vrecord can't find a preferred font to use, please report this error to https://github.com/amiaopensource/vrecord/issues"
    fi
    HARDWARE_REPORT=$(system_profiler SPHardwareDataType)
    CORE_COUNT="$(_parse_report "Total Number of Cores" "${HARDWARE_REPORT}")"
    OPEN_COMMAND="open"
    ZCAT_COMMAND="gzcat"
    DECKLINK_DRIVER_PLIST="/Library/Extensions/DeckLink_Driver.kext/Contents/Info.plist"
    VIDEO_CARD_DRIVER_VERSION="$(defaults read "${DECKLINK_DRIVER_PLIST}" CFBundleVersion)"
elif [[ "${QUERY_OS_TYPE}" = "Linux" ]] ; then
    OS_TYPE="linux"
    DEFAULTFONT="/usr/share/fonts/truetype/liberation/LiberationSans-Regular.ttf"
    HARDWARE_REPORT=$(lscpu)
    CORE_COUNT="$(nproc --all)"
    OPEN_COMMAND="xdg-open"
    ZCAT_COMMAND="zcat"
else
    echo "Unsupported OS, ${QUERY_OS_TYPE}, detected. Exiting."
    exit 1
fi

# optional dependency checks
GNUPLOT_INSTALLED="$(if command -v gnuplot >/dev/null ; then echo true ; else echo false ; fi)"
MEDIACONCH_INSTALLED="$(if command -v mediaconch >/dev/null ; then echo true ; else echo false ; fi)"
MKVPROPEDIT_INSTALLED="$(if command -v mkvpropedit >/dev/null ; then echo true ; else echo false ; fi)"
MPV_INSTALLED="$(if command -v mpv >/dev/null ; then echo true ; else echo false ; fi)"
QCLI_INSTALLED="$(if command -v qcli >/dev/null ; then echo true ; else echo false ; fi)"

# command-line options to set media id and original variables
OPTIND=1
while getopts ":herpaxgvI:O:i:" opt ; do
    case "${opt}" in
        h) _usage ; exit 0 ;;
        e) RUNTYPE="edit" ;;
        r) RUNTYPE="record" ;;
        p) RUNTYPE="passthrough" ;;
        a) RUNTYPE="audiopassthrough" ;;
        x) RUNTYPE="reset" ;;
        g) RUNTYPE="GUI" ; GUI=1 ;;
        v) VERBOSE="true" ;;
        I) EXTRAINPUTOPTIONS=(${OPTARG}) ;;
        O) EXTRAOUTPUTOPTIONS=(${OPTARG}) ;;
        i) ALT_INPUT="${OPTARG}" ;;
        :) _report -w "Option -${OPTARG} requires an argument" ; _usage ; exit 1 ;;
        *) _report -w "Error: bad option -${OPTARG}" ; _usage ; exit 1 ;;
    esac
done
shift "$((OPTIND-1))"

_verify_conf_items(){
    # some options to handle situations where an older configuration file needs to store updated options
    CONF_VARIABLE="${1}"
    CONF_FILE="${2}"
    if [[ "$(grep -c "${CONF_VARIABLE}" "${CONF_FILE}")" = "0" ]] ; then
        if [[ "${CONF_VARIABLE}" = "FFV1_SLICE_CHOICE" ]] ; then
            echo "${CONF_VARIABLE}=\"16\"" >> "${CONF_FILE}"
        else
            echo "${CONF_VARIABLE}=\"\"" >> "${CONF_FILE}"
        fi
    fi
}

if [[ -f "${CONFIG_FILE}" ]] ; then
    _verify_conf_items "FFV1_SLICE_CHOICE" "${CONFIG_FILE}"
    . "${CONFIG_FILE}"
elif [[ "${RUNTYPE}" = "record" || "${RUNTYPE}" = "edit" ]] ; then
    _report -d "No configuration file, restarting in edit mode."
    touch "${CONFIG_FILE}"
    exec "${SCRIPTNAME}" -e
fi

_gtk_vbox_list() {
    VARIABLE_NAME="${1}"
    LABEL="${2}"
    shift 2
    OPTION_LIST=("${@}")
    SELECTION="$(_get_index_of_value "${!VARIABLE_NAME}" "${OPTION_LIST[@]}")"
    LIST="$(_expand_list2items "${OPTION_LIST[@]}")"

    _get_list_extras(){
        if [[ "${VARIABLE_NAME}" == "VIDEO_CODEC_CHOICE" ]] ; then
            echo '<action condition="command_is_true( [ \"$VIDEO_CODEC_CHOICE\" = \"FFV1 version 3\" ] && echo true)">enable:FFV1_SLICE_CHOICE</action>
                  <action condition="command_is_true( [ \"$VIDEO_CODEC_CHOICE\" != \"FFV1 version 3\" ] && echo true)">disable:FFV1_SLICE_CHOICE</action>'
        elif [[ "${VARIABLE_NAME}" == "CONTAINER_CHOICE" ]] ; then
            echo '<action condition="command_is_true( [ \"$CONTAINER_CHOICE\" = \"Matroska\" ] && echo true)">enable:EMBED_LOGS_CHOICE</action>
                  <action condition="command_is_true( [ \"$CONTAINER_CHOICE\" != \"Matroska\" ] && echo true)">disable:EMBED_LOGS_CHOICE</action>'
        fi
    }

    _get_vbox_extras(){
        if [[ "${VARIABLE_NAME}" == "TIMECODE_CHOICE" ]] ; then
            echo "
            <button>
                <label>Scan timecode types</label>
                <action type=\"exit\">timecode_scan</action>
            </button>"
        elif [[ "${VARIABLE_NAME}" == "EMBED_LOGS_CHOICE" ]] ; then
            echo "<sensitive>$(if $MKVPROPEDIT_INSTALLED ; then echo true ; else echo false ; fi)</sensitive>"
        elif [[ "${VARIABLE_NAME}" == "QCTOOLSXML_CHOICE" ]] ; then
            echo "<sensitive>$(if $QCLI_INSTALLED ; then echo true ; else echo false ; fi)</sensitive>"
        fi
    }

    echo "<vbox>
      <text>
          <label>${LABEL}</label>
      </text>
      <list selection-mode=\"1\" selected-row=\"${SELECTION}\">
          <variable>${VARIABLE_NAME}</variable>
          ${LIST}
          $(_get_list_extras)
      </list>
      $(_get_vbox_extras)
    </vbox>"
}

_get_decklink_inputs(){
    # get information on what input device options are available
    unset DECKLINK_DEVICES
    while read decklink_device ; do
      DECKLINK_DEVICES+=("${decklink_device}")
    done < <("${FFMPEG_BIN}" -nostdin -v 0 -sources decklink | awk -F'[][]' '{print $2}' | grep -v "^$")
    if [[ "${#DECKLINK_DEVICES[@]}" = 1 ]] ; then # default to first input if only one
      DECKLINK_INPUT_CHOICE="${DECKLINK_DEVICES[0]}"
    elif [[ -z "$("${FFMPEG_BIN}" -nostdin -v 0 -sources decklink)" ]] ; then
        FFMPEG_DECKLINK_SUPPORT="N"
    fi
}
_get_avfoundation_inputs(){
    # set avfoundation input options
    unset AVFOUNDATION_DEVICES
    while read avf_device ; do
        AVFOUNDATION_DEVICES+=("${avf_device}")
    done < <("${FFMPEG_BIN}" -nostdin -hide_banner -f avfoundation -list_devices 1 -i dummy 2>&1 | grep -o "\[[0-9]\].*" | cut -d " " -f2-)
}

_get_decklink_inputs
_get_avfoundation_inputs

_edit_prefs() {
  _expand_list2items(){
    LIST=( "$@" )
    for i in "${LIST[@]}" ; do
      if [[ "$i" == "Quality Control View (mpv)" ]] && ! $MPV_INSTALLED ; then
          :
      else
        echo "<item>${i}</item>"
      fi
    done
  }
  _get_index_of_value(){
    # run with function, value to look for as first argument, and array to look in as 2nd argument, such function as
    # _get_index_of_value "${VIDEO_INPUT_CHOICE}" "${VIDEO_INPUT_OPTIONS[@]}"
    VALUE="${1}"
    shift
    LIST=( "$@" )
    INDEX=0
    MATCH=""
    for ITEM in "${LIST[@]}" ; do
      if [[ "${VALUE}" = "${ITEM}" ]] ; then
        MATCH="$INDEX"
      fi
      (( ++INDEX ))
    done
    if [[ -n "${MATCH}" ]] ; then
      echo -n "${MATCH}"
    fi
  }

DECKLINK_INPUT_GUI="
<frame Decklink input options>
    <vbox>
        <hbox space-expand=\"true\">
            $(_gtk_vbox_list "DECKLINK_INPUT_CHOICE"    "Select Video Card"             "${DECKLINK_DEVICES[@]}")
            $(_gtk_vbox_list "VIDEO_INPUT_CHOICE"       "Select Video Input"            "${VIDEO_INPUT_OPTIONS[@]}")
            $(_gtk_vbox_list "AUDIO_INPUT_CHOICE"       "Select Audio Input"            "${AUDIO_INPUT_OPTIONS[@]}")
            $(_gtk_vbox_list "AUDIO_MAPPING_CHOICE"     "Select Audio Channel Mapping"  "${CHANNEL_MAPPING_OPTIONS[@]}" )
            $(_gtk_vbox_list "STANDARD_CHOICE"          "Select Standard"               "${STANDARD_OPTIONS[@]}")
            $(_gtk_vbox_list "VIDEO_BIT_DEPTH_CHOICE"   "Select Video Bit Depth"        "${VIDEO_BITDEPTH_OPTIONS[@]}")
            $(_gtk_vbox_list "TIMECODE_CHOICE"          "Select timecode format"        "${TIMECODE_OPTIONS[@]}")
        </hbox>
        <checkbox>
            <label>Invert Second Channel of Audio (WARNING: Do not use this option unless required)</label>
            <default>false</default>
            <variable>INVERT_PHASE</variable>
        </checkbox>
        <frame Output file options>
            <hbox space-expand=\"true\">
                $(_gtk_vbox_list "EMBED_LOGS_CHOICE"        "Embed digitization logs in video file (Matroska ONLY)" "${EMBED_LOGS_OPTIONS[@]}")
                $(_gtk_vbox_list "CONTAINER_CHOICE"         "Select File Format"            "${CONTAINER_OPTIONS[@]}")
                $(_gtk_vbox_list "FFV1_SLICE_CHOICE"        "FFV1 Slice Count"              "${FFV1_SLICE_OPTIONS[@]}")
                $(_gtk_vbox_list "VIDEO_CODEC_CHOICE"       "Select Video Codec"            "${VIDEO_CODEC_OPTIONS[@]}")
                $(_gtk_vbox_list "AUDIO_CODEC_CHOICE"       "Select Audio Codec"            "${AUDIO_CODEC_OPTIONS[@]}")
            </hbox>
        </frame>
    </vbox>
</frame>"

AVFOUNDATION_INPUT_GUI="
<frame AVFoundation input options>
    <vbox>
        <hbox space-expand=\"true\">
            $(_gtk_vbox_list "AVF_INPUT_CHOICE"         "Select a DV Device"           "${AVFOUNDATION_DEVICES[@]}")
        </hbox>
    </vbox>
</frame>"

  export MAIN_DIALOG="<window title=\"vrecord configuration\">
    <vbox>
        <text>
            <label>Set file recording options.</label>
        </text>
        <frame Input Options>
        <notebook page=\"${DEVICE_INPUT_CHOICE}\" tab-labels=\"Decklink|DV|\">
            ${DECKLINK_INPUT_GUI}
            ${AVFOUNDATION_INPUT_GUI}
            <variable>DEVICE_INPUT_CHOICE</variable>
        </notebook>
        </frame>
        <hbox>
            <frame Optional Tools>
                <hbox>
                    <text>
                        <label>gnuplot: </label>
                    </text>
                    <pixmap stock-icon-size=\"1\" tooltip-text=\"If gnuplot is installed, vrecord can may a graph output from qctools reports.\">
                        <input file stock=\"$(if $GNUPLOT_INSTALLED ; then echo gtk-yes ; else echo gtk-no ; fi)\"></input>
                    </pixmap>
                </hbox>
                <hbox>
                    <text>
                        <label>mediaconch: </label>
                    </text>
                    <pixmap stock-icon-size=\"1\" tooltip-text=\"If mediaconch is installed, vrecord can perform checks after capture to ensure the file is as expected.\">
                        <input file stock=\"$(if $MEDIACONCH_INSTALLED ; then echo gtk-yes ; else echo gtk-no ; fi)\"></input>
                    </pixmap>
                </hbox>
                <hbox>
                    <text>
                        <label>mkvpropedit: </label>
                    </text>
                    <pixmap stock-icon-size=\"1\" tooltip-text=\"If mkvpropedit is installed, vrecord can embed capture logs into any Matroska recordings.\">
                        <input file stock=\"$(if $MKVPROPEDIT_INSTALLED ; then echo gtk-yes ; else echo gtk-no ; fi)\"></input>
                    </pixmap>
                </hbox>
                <hbox>
                    <text>
                        <label>mpv: </label>
                    </text>
                    <pixmap stock-icon-size=\"1\" tooltip-text=\"If mpv is installed, vrecord can offer additional playback view options.\">
                        <input file stock=\"$(if $MPV_INSTALLED ; then echo gtk-yes ; else echo gtk-no ; fi)\"></input>
                    </pixmap>
                </hbox>
                <hbox>
                    <text>
                        <label>qcli: </label>
                    </text>
                    <pixmap stock-icon-size=\"1\" tooltip-text=\"If qcli is installed, vrecord can offer options to create QCTools reports during or after capture.\">
                        <input file stock=\"$(if $QCLI_INSTALLED ; then echo gtk-yes ; else echo gtk-no ; fi)\"></input>
                    </pixmap>
                </hbox>
            </frame>
            <frame Playback options>
                <hbox space-expand=\"true\">
                    $(_gtk_vbox_list "PLAYBACKVIEW_CHOICE"      "Select View (for recording)"   "${PLAYBACKVIEW_OPTIONS[@]}")
                    $(_gtk_vbox_list "PLAYBACKVIEW_CHOICE_PASS" "Select View (for passthrough)" "${PLAYBACKVIEW_PASS_OPTIONS[@]}")
                </hbox>
            </frame>
            <frame Sidecar file options>
                <hbox space-expand=\"true\">
                    $(_gtk_vbox_list "FRAMEMD5_CHOICE"          "Create frame-level MD5 checksums? (recommended)"       "${FRAMEMD5_OPTIONS[@]}")
                    $(_gtk_vbox_list "QCTOOLSXML_CHOICE"        "Create QCTools XML?"           "${QCTOOLSXML_OPTIONS[@]}")
                </hbox>
            </frame>
        </hbox>
        <hbox>
            <frame File naming options>
                <hbox space-expand=\"true\">
                    <vbox>
                        <text>
                            <label>Enter an optional file prefix</label>
                        </text>
                        <entry>
                            <default>\"${PREFIX}\"</default>
                            <variable>PREFIX</variable>
                        </entry>
                    </vbox>
                    <vbox>
                        <text>
                            <label>Enter an optional file suffix</label>
                        </text>
                        <entry>
                            <default>\"${USER_SUFFIX}\"</default>
                            <variable>USER_SUFFIX</variable>
                        </entry>
                    </vbox>
                    <vbox>
                        <checkbox>
                            <label>Check this to turn off appending of suffixes</label>
                            <default>\"${NO_SUFFIX}\"</default>
                            <variable>NO_SUFFIX</variable>
                        </checkbox>
                    </vbox>
                </hbox>
            </frame>
            <frame Recording event options>
                <hbox space-expand=\"true\">
                    <vbox>
                        <text>
                            <label>Set recording time (integer or decimal) in minutes</label>
                        </text>
                        <entry activates_default=\"true\" tooltip-text=\"Suggested:23 33 63 93. Leave blank for indefinite recording time\">
                            <default>\"${DURATION}\"</default>
                            <variable>DURATION</variable>
                        </entry>
                    </vbox>
                    <vbox>
                        <text>
                            <label>Enter the name of the person digitizing this tape.</label>
                        </text>
                        <entry>
                            <variable>TECHNICIAN</variable>
                        </entry>
                    </vbox>
                </hbox>
            </frame>
        </hbox>
        <hbox>
            <frame Select a recording directory>
                <hbox>
                    <entry accept=\"directory\">
                        <variable>DIR</variable>
                        <default>\"${DIR}\"</default>
                    </entry>
                    <button>
                        <input file stock=\"gtk-open\"></input>
                        <variable>DIRBROWSE</variable>
                        <action type=\"fileselect\">DIR</action>
                    </button>
                </hbox>
            </frame>
            <frame Select a directory for auxiliary files (leave blank to match the recording directory).>
                <hbox>
                    <entry accept=\"directory\" tooltip-text=\"select the directory for automatically generated logs and checksums\">
                        <variable>LOGDIR</variable>
                        <default>\"${LOGDIR}\"</default>
                    </entry>
                    <button>
                        <input file stock=\"gtk-open\"></input>
                        <variable>LOGDIRBROWSE</variable>
                        <action type=\"fileselect\">LOGDIR</action>
                    </button>
                </hbox>
            </frame>
        </hbox>
        <vbox>
            <hbox>
                <button ok>
                    <variable>OKBUTTON</variable>
                </button>
                <button cancel>
                </button>
                <button>
                    <label>Refresh</label>
                    <action type=\"exit\">refresh</action>
                </button>
            </hbox>
        </vbox>
    </vbox>
</window>"

    eval $(gtkdialog --center --program MAIN_DIALOG)
}

_home_gui(){
  export HOME_DIALOG="<window title=\"Welcome to Vrecord!\">
    <vbox>
        <vbox>
            <hbox>
                <button>
                    <label>Record</label>
                    <input file>${RESOURCE_PATH}/vrecord_logo.png</input>
                    <action type=\"exit\">record</action>
                </button>
                <button>
                    <label>Passthrough</label>
                    <input file>${RESOURCE_PATH}/vrecord_logo_playback.png</input>
                    <action type=\"exit\">passthrough</action>
                </button>
                <button>
                    <label>Audio Check</label>
                    <input file>${RESOURCE_PATH}/vrecord_logo_audio.png</input>
                    <action type=\"exit\">audiopassthrough</action>
                </button>
                </hbox>
                <hbox>
                <button>
                    <label>Edit Settings</label>
                    <input file>${RESOURCE_PATH}/vrecord_logo_edit.png</input>
                    <action type=\"exit\">edit</action>
                </button>
                <button>
                    <label>Help</label>
                    <input file>${RESOURCE_PATH}/vrecord_logo_help.png</input>
                    <action>man vrecord</action>
                </button>
                <button>
                    <label>Documentation</label>
                    <input file>${RESOURCE_PATH}/vrecord_logo_documentation.png</input>
                    <action>${OPEN_COMMAND} https://github.com/amiaopensource/vrecord#vrecord-documentation</action>
                </button>
            </hbox>
        </vbox>
        <hbox>
            <button cancel></button>
        </hbox>
    </vbox>
</window>"

  RUNTYPE=$(gtkdialog --center --program=HOME_DIALOG | grep "^EXIT=" | cut -d= -f2 | sed 's/"//g')

  if [[ "${RUNTYPE}" = "Cancel" ]] ; then
      echo "Exiting Vrecord. Goodbye!" && exit 0
  fi
}

# relaunch GUI in GUI mode/exit script in terminal mode
_gui_return(){
    if [[ "${GUI}" = 1 ]] ; then
        _home_gui
    else
        exit 0
    fi
}

_report_var(){
    while [[ "${@}" != "" ]] ; do
        VAR_NAME="${1}"
        VAR_VALUE="${!1}"
        shift
        if   [[ "$VAR_NAME" == "DECKLINK_INPUT_CHOICE" ]] && [[ "${DEVICE_INPUT_CHOICE}" != "0" ]] ; then
            :
        elif [[ "$VAR_NAME" == "AVF_INPUT_CHOICE" ]] && [[ "${DEVICE_INPUT_CHOICE}" != "1" ]] ; then
            :
        elif [[ "$VAR_NAME" == "FFV1_SLICE_CHOICE" ]] && [[ "${VIDEO_CODEC_CHOICE}" != "FFV1 version 3" ]] ; then
            :
        elif [[ "$VAR_NAME" == "EMBED_LOGS_CHOICE" ]] && [[ "${CONTAINER_CHOICE}" != "Matroska" ]] ; then
            :
        else
            printf " %-24s = %s \n" "$VAR_NAME" "$VAR_VALUE"
        fi
    done
}

# edit mode
_edit_mode(){

    _get_decklink_inputs
    _get_avfoundation_inputs
    _edit_prefs
    # check that gtkdialog _edit_prefs was exited with OK button
    if [[ "${EXIT}" = "OK" ]] ; then
        _duration_check
        # report back options
        if [[ -z "${LOGDIR}" ]] ; then
            LOGDIR="${DIR}"
            echo "As auxiliary files directory was left blank, logs will be written to recording directory at ${DIR}."
        fi
        echo "Variables set:"
        _report_var DEVICE_INPUT_CHOICE AVF_INPUT_CHOICE DECKLINK_INPUT_CHOICE DIR LOGDIR CONTAINER_CHOICE VIDEO_INPUT_CHOICE AUDIO_INPUT_CHOICE VIDEO_CODEC_CHOICE FFV1_SLICE_CHOICE AUDIO_CODEC_CHOICE VIDEO_BIT_DEPTH_CHOICE AUDIO_MAPPING_CHOICE TIMECODE_CHOICE STANDARD_CHOICE QCTOOLSXML_CHOICE FRAMEMD5_CHOICE EMBED_LOGS_CHOICE PLAYBACKVIEW_CHOICE PLAYBACKVIEW_CHOICE_PASS DURATION TECHNICIAN PREFIX USER_SUFFIX NO_SUFFIX
        if [[ "${INVERT_PHASE}" = 'true' ]] ; then
            echo -e " \033[101mWARNING: Option to invert phase of second audio channel has been selected\033[0m"
        fi
        if [ "${VIDEO_CODEC_CHOICE}" = "FFV1 version 3" -a "${CONTAINER_CHOICE}" = "MXF" ] ; then
            echo -e " \033[101mWARNING: Incompatible video codecs and CONTAINERs have been selected\033[0m"
        elif [ "${VIDEO_CODEC_CHOICE}" = "ProRes" -a "${CONTAINER_CHOICE}" = "MXF" ] ; then
            echo -e " \033[101mWARNING: Incompatible video codecs and CONTAINERs have been selected\033[0m"
        elif [ "${VIDEO_CODEC_CHOICE}" = "ProRes (HQ)" -a "${CONTAINER_CHOICE}" = "MXF" ] ; then
            echo -e " \033[101mWARNING: Incompatible video codecs and CONTAINERs have been selected\033[0m"
        elif [ "${AUDIO_CODEC_CHOICE}" = "24-bit FLAC" -a "${CONTAINER_CHOICE}" = "QuickTime" ] ; then
            echo -e " \033[101mWARNING: Incompatible audio codecs and CONTAINERs have been selected\033[0m"
        fi
        if [ "${EMBED_LOGS_CHOICE}" = "Yes" -a "${CONTAINER_CHOICE}" != "Matroska" ] ; then
            _report -w "WARNING: Logs cannot be embedded in non-Matroska files. This vrecord session will generate logs in ${LOGDIR}, but will not embed them in your video file."
        fi
        echo ""
        # write config file
        {
            echo "# Set these variables to a valid option or leave as empty quotes (like \"\") to request each run."
            for COMMENT_LINE in DEVICE_INPUT_CHOICE VIDEO_INPUT_CHOICE AUDIO_INPUT_CHOICE CONTAINER_CHOICE VIDEO_CODEC_CHOICE FFV1_SLICE_CHOICE AUDIO_CODEC_CHOICE\
            VIDEO_BIT_DEPTH_CHOICE AUDIO_MAPPING_CHOICE TIMECODE_CHOICE STANDARD_CHOICE QCTOOLSXML_CHOICE FRAMEMD5_CHOICE \
            EMBED_LOGS_CHOICE PLAYBACKVIEW_CHOICE PLAYBACKVIEW_CHOICE_PASS DIR LOGDIR INVERT_PHASE DURATION PREFIX USER_SUFFIX NO_SUFFIX TECHNICIAN \
            AVF_INPUT_CHOICE DECKLINK_INPUT_CHOICE ; do
                echo "${COMMENT_LINE}=\"${!COMMENT_LINE}\""
            done
        } > "${CONFIG_FILE}"
        . "${CONFIG_FILE}"
    elif [[ "${EXIT}" = "refresh" ]] ; then
        RUNTYPE="edit"
    elif [[ "${EXIT}" = "timecode_scan" ]] ; then
        _report -dt "Scanning each supported type of timecode."
        for timecode_type in "${TIMECODE_OPTIONS[@]}" ; do
            tc_value="$("${FFPROBE_BIN}" "${GRAB_INPUT[@]}" -timecode_format "${timecode_type}" -show_entries stream_tags=timecode -of default=nw=1:nk=1 2>/dev/null)"
            if [[ -z "${tc_value}" ]] ; then
                tc_value="none"
            fi
            echo "${timecode_type}: ${tc_value}"
        done
        RUNTYPE="edit"
    elif [[ "${EXIT}" = "Cancel" ]] ; then
        _report -d "Editing of preferences was canceled by the user."
    fi
    if [[ "${GUI}" = 1 ]] ; then
        _home_gui
    elif [[ "${EXIT}" = "OK" || ${EXIT} = "Cancel" ]] ; then
        RUNTYPE="record"
        _report -nd "Press [q] to quit, [p] to enter passthrough mode or any other key to proceed: "
        read AFTEREDITRESPONSE
        if [[ "${AFTEREDITRESPONSE}" = "q" ]] ; then
            _report -d "Bye then"
            exit 0
        elif [[ "${AFTEREDITRESPONSE}" = "p" ]] ; then
            RUNTYPE="passthrough"
        fi
    fi
}

# passthrough and audiopassthrough modes
_passthrough_mode(){
    _set_ffplay_options
    if [[ "${MEDIA_PLAYER_CHOICE}" = "mpv" ]] ; then
        _check_mpv
        "${FFMPEG_BIN}" -nostats "${GRAB_INPUT[@]}" 2> >(tee "${VRECORD_INPUT_TMP}" 1>&2) \
        "${PIPE_OUTPUT[@]}" | \
        mpv "${MPVOPTS[@]}" --title="${WINDOW_NAME}" -
    elif [[ "${PLAYBACKVIEW_CHOICE_PASS}" = "Audio + Video" ]] ; then
        if [[ "${DEVICE_INPUT_CHOICE}" = "1" ]] ; then
            unset PIPE_OUTPUT[0] && unset PIPE_OUTPUT[1]
            "${FFMPEG_BIN}" -nostdin -hide_banner -nostats "${INPUTOPTIONS[@]}" "${GRAB_INPUT[@]}" -c copy -f rawvideo - | "${FFMPEG_BIN}" -i - "${PIPE_OUTPUT[@]}" 2> "${VRECORD_INPUT_TMP}" | \
            "${FFPLAY_BIN}" -window_title "${WINDOW_NAME}" -f lavfi "movie='pipe\:0':${PLAYBACKFILTER}"
        else
            "${FFMPEG_BIN}" -nostdin -hide_banner -nostats "${INPUTOPTIONS[@]}" "${GRAB_INPUT[@]}" "${PIPE_OUTPUT[@]}" 2> "${VRECORD_INPUT_TMP}" | \
            "${FFPLAY_BIN}" -window_title "${WINDOW_NAME}" -f lavfi "movie='pipe\:0':${PLAYBACKFILTER}"
        fi
    else
        "${FFPLAY_BIN}" "${FFPLAY_OPTIONS[@]}" 2> >(tee "${VRECORD_INPUT_TMP}" 1>&2)
    fi
    _gui_return
}

_audiopassthrough_mode(){
    PLAYBACKVIEW_CHOICE_PASS="Audio + Video"
    _lookup_choice "Audio + Video"
    _passthrough_mode
}

# check validity of duration value
_duration_check(){
    # Sets up function to verify validity of duration settings
    if [[ -n "${DURATION}" ]] ; then
        if ! [[ "${DURATION}" =~ ^$|^[0-9]+$|^[0-9]+\.[0-9]*$|^\.[0-9]+$ ]] ; then
            _report -w "Illegal value for recording time. Input must only be numbers."
            exit 1
        fi
        if (( $(bc <<< "${DURATION} == 0") )) ; then
            _report -w "A recording duration of zero is invalid."
            exit 1
        fi
    fi
}

# create a capture log of decisions made in vrecord
_writeingestlog(){
    if [[ "${INGESTLOG}" ]] ; then
        KEY="${1}"
        shift
        VALUE="${@}"
        # need to add yaml style escaping
        echo "${KEY}: ${VALUE}" >> "${INGESTLOG}"
    else
        _report -wt "The _writeingestlog function was called, but the ingestlog file (${INGESTLOG}) is not declared."
    fi
}

# create a jpeg of qc data graphs for quick assessment
_qcgraphimage(){
    # get audio data
    qctools_CONFIGFILE_A="$(_maketemp .astats_A.csv)"
    "${ZCAT_COMMAND}" "$1" | perl -nle 'print if not m{lavfi.(?!astats.Overall.Min_level|astats.Overall.Max_level|astats.Overall.Peak_level|aphasemeter.phase)}' | xmlstarlet select -t -m "//ffprobe:ffprobe/frames/frame[@media_type='audio']" \
       -v "@pkt_pts_time" -o " " \
       -v "tag[@key='lavfi.astats.Overall.Max_level']/@value" -o " " \
       -v "tag[@key='lavfi.astats.Overall.Min_level']/@value" -o " " \
       -v "tag[@key='lavfi.astats.Overall.Peak_level']/@value" -o " " \
       -v "tag[@key='lavfi.aphasemeter.phase']/@value" -n > "${qctools_CONFIGFILE_A}"
    # get video data
    qctools_CONFIGFILE_V="$(_maketemp .signalstats.V.csv)"
    "${ZCAT_COMMAND}" "$1" | perl -nle 'print if not m{lavfi.(?!signalstats.BRNG|signalstats.TOUT|signalstats.SATMAX|signalstats.SATAVG|ssim.Y|ssim.U|ssim.V)}' | xmlstarlet select -t -m "//ffprobe:ffprobe/frames/frame[@media_type='video']" \
       -v "@pkt_pts_time" -o " " \
       -v "tag[@key='lavfi.signalstats.TOUT']/@value" -o " " \
       -v "tag[@key='lavfi.signalstats.BRNG']/@value" -o " " \
       -v "tag[@key='lavfi.signalstats.SATMAX']/@value" -o " " \
       -v "tag[@key='lavfi.signalstats.SATAVG']/@value" -o " " \
       -v "tag[@key='lavfi.ssim.Y']/@value" -o " " \
       -v "tag[@key='lavfi.ssim.U']/@value" -o " " \
       -v "tag[@key='lavfi.ssim.V']/@value" -n > "${qctools_CONFIGFILE_V}"

    # determine SATURATION scale
    VBitdepth="$("${ZCAT_COMMAND}" "$1" | perl -nle 'print if not m{<frame|</frame|<tag}' | xmlstarlet sel -t -v "//stream[@codec_type='video']/@pix_fmt" -n
    )"
    if [[ "${VBitdepth}" = "yuv422p10le" ]] ; then
        SATpalette="(0'#a0a0a0',80'#bebebe',177.4'#c8c800',322'#a0ff20',354.8'#00ff00',413.8'#006400',433.46'#00ff00',453.13'#a0ff20',472.8'#ffa500',496'#ff0000')"
        SATcbrange="[0:496]"
        SATyrange="[0:725]"
    else
        SATpalette="(0'#a0a0a0',20'#bebebe',44.35'#c8c800',80'#a0ff20',88.7'#00ff00',103.45'#006400',108.2'#00ff00',113.2'#a0ff20',118.2'#ffa500',124'#ff0000')"
        SATcbrange="[0:124]"
        SATyrange="[0:183]"
    fi

    echo "set terminal jpeg size 1920, 1080
    set output '${LOGDIR}/${FULL_OUTPUT_ID}_QC_output_graphs.jpeg'
    set term jpeg font 'times,12'
    set multiplot layout 7, 1 title '${ID} QC Data Graphs (ver.2)' margins screen .05,.93, .05, .93 spacing screen 0, char .7
    set style line 11 lc rgb '#808080' lt 1
    set border 15 back ls 11
    set format x '%tH:%tM:%.1tS' time
    set format x2 '%tH:%tM:%.1tS' time
    set x2tics border out nomirror
    set xtics border mirror in scale 1.5,.7 format ''
    set ytics border out nomirror font 'times,10'
    set grid y
    set grid x
    set grid mxtics
    set colorbox vertical back user origin graph 1.01,0 size char 1,6
    set cbtics font 'times,10'
    set key inside right top reverse samplen .00
    unset key
    set yrange [-2147483648.:2147483648.]
    set palette model RGB defined (-0.8'#ff0000',-0.6'#ffa500',-0.4'#a0ff20',-0.2'#00ff00',0'#006400',0.2'#00ff00',0.4'#a0ff20',.6'#ffa500',0.8'#ff0000') maxcolors 128
    set cbrange [-2147483648.:2147483648.]
    set style fill solid
    set label 1 'Min/Max Level' at graph .5,.9 center front
    plot '${qctools_CONFIGFILE_A}' using 1:2:2 with boxes palette title 'Max Level', '' using 1:3:3 with boxes palette title 'Min Level'
    unset cbrange
    unset x2tics
    set yrange [-70:0]
    set cbrange [0:-50.]
    set palette model RGB defined (-50'#006400',-35'#00ff00',-15'#a0ff20',-5'#ffa500',-0.5'#ff0000') maxcolors 128
    set style line 15 linecolor palette lw 4
    set label 1 'Peak Level (dB)' at graph .5,.9 front
    plot '' using 1:4:4 with lines ls 15 title 'Peak Level (dB)'
    unset yrange
    unset cbrange
    set palette model RGB defined (-0.8'#ff0000',-0.6'#ffa500',-0.4'#a0ff20',0'#00ff00',1'#006400') maxcolors 128
    set cbrange [-0.8:1]
    set yrange [-1:1]
    set style line 25 linecolor palette lw 4
    set label 1 'Audio Phase' at graph .5,.9 front
    plot '' using 1:5:5 with lines ls 25 title 'Audio Phase'
    unset yrange
    unset cbrange
    set palette model RGB defined (0'#006400',0.01'#00ff00',0.02'#fffb20',.04'#ffa500',0.05'#ff0000') maxcolors 128
    set cbrange [0:.05]
    set yrange [0:.1]
    set label 1 '% Outside of Broadcast Range' at graph .5,.9 front
    plot '${qctools_CONFIGFILE_V}' using 1:3:3 with boxes palette title '% Outside of Broadcast Range'
    unset yrange
    set style line 10 linecolor '#804080' lw 2
    set label 1 '% Temporal OUTliers' at graph .5,.9 front
    plot '' using 1:2 with lines ls 10 title '% Temporal OUTliers'
    unset yrange
    unset cbrange
    set style line 1 linecolor '#f03232' lw 2
    set style line 2 linecolor '#006400' lw 2
    set style line 3 linecolor '#00ff00' lw 2
    set style line 4 linecolor '#f03232' lw 2
    set style line 5 linecolor '#000000' lw 2
    set style line 6 linecolor '#00008b' lw 2
    set yrange ${SATyrange}
    set palette model RGB defined ${SATpalette} maxcolors 128
    set cbrange ${SATcbrange}
    unset label
    set key at graph 1.06,.5 center vertical Left noopaque noreverse font 'times,9'
    set label 1 'Saturation Level' at graph .5,.9 center front
    plot '' using 1:4:4 with boxes palette title 'SatMax', '' using 1:5 with lines ls 5 title 'SatAvg'
    unset yrange
    unset cbrange
    unset xtics
    unset key
    set key at graph 1.06,.5 right vertical Right noopaque noreverse
    set x2tics border mirror in scale 1.5,.7 format ''
    set xtics border out nomirror format '%tH:%tM:%.1tS' time
    set label 1 'Structural SImilarity Metric' at graph .5,.1 center front
    plot '' using 1:6 with lines ls 5 title 'SSIM-Y', '' using 1:7 with lines ls 2 title 'SSIM-U', '' using 1:8 with lines ls 6 title 'SSIM-V'
    " | gnuplot
}

# decipher vrecord options as specified by user
_lookup_choice(){
    case "${2}" in
        "quit"|"Quit"|"QUIT"|"q"|"Q") _report -dt "Bye." ; exit ;;
    esac
    case "${1}" in
        # video inputs
        "Composite") VIDEO_INPUT="composite" ;;
        "SDI")       VIDEO_INPUT="sdi" ;;
        "Component") VIDEO_INPUT="component" ;;
        "S-Video")   VIDEO_INPUT="s_video" ;;

        # audio inputs
        "Analog")                  AUDIO_INPUT="analog" ;;
        "SDI Embedded Audio")      AUDIO_INPUT="embedded" ;;
        "Digital Audio (AES/EBU)") AUDIO_INPUT="aes_ebu" ;;

        # container
        "QuickTime")
            EXTENSION="mov"
            MIDDLEOPTIONS+=(-movflags write_colr)
            FORMAT="mov" ;;
        "Matroska")
            EXTENSION="mkv"
            FORMAT="matroska" ;;
        "AVI")
            EXTENSION="avi"
            FORMAT="avi" ;;
        "MXF")
            EXTENSION="mxf"
            FORMAT="mxf" ;;
        "MP4")
            EXTENSION="mp4"
            MIDDLEOPTIONS+=(-movflags write_colr)
            FORMAT="mp4" ;;

        # video codec
        "Uncompressed Video")
            if [[ "${PIXEL_FORMAT}" = "yuv422p10" ]] ; then
                VIDEOCODECNAME="Uncompressed 10-bit 4:2:2"
                MIDDLEOPTIONS+=(-c:v v210)
            elif [[ "${PIXEL_FORMAT}" = "uyvy422" ]] ; then
                VIDEOCODECNAME="Uncompressed 8-bit 4:2:2"
                MIDDLEOPTIONS+=(-c:v rawvideo -pix_fmt uyvy422 -tag:v 2vuy)
            fi ;;
        "FFV1 version 3")
            VIDEOCODECNAME="FFV1 version 3"
            MIDDLEOPTIONS+=(-c:v ffv1 -level 3 -g 1 -slices "${FFV1_SLICE_CHOICE}" -slicecrc 1)
            SUFFIX="_ffv1" ;;
        "JPEG2000")
            VIDEOCODECNAME="JPEG2000"
            MIDDLEOPTIONS+=(-c:v libopenjpeg)
            SUFFIX="_j2k" ;;
        "ProRes")
            VIDEOCODECNAME="Apple ProRes 422"
            MIDDLEOPTIONS+=(-c:v prores_ks -flags +ildct -profile:v 2)
            SUFFIX="_prores" ;;
        "ProRes (HQ)")
            VIDEOCODECNAME="Apple ProRes 422 HQ"
            MIDDLEOPTIONS+=(-c:v prores_ks -flags +ildct -profile:v 3)
            SUFFIX="_prores" ;;
        "h264")
            VIDEOCODECNAME="H.264"
            MIDDLEOPTIONS+=(-c:v libx264 -crf 18 -pix_fmt yuv420p)
            SUFFIX="" ;;
        "HuffYUV")
            VIDEOCODECNAME="HuffYUV"
            if [[ "${PIXEL_FORMAT}" = "yuv422p10" ]] ; then
                MIDDLEOPTIONS+=(-c:v ffvhuff -pix_fmt yuv422p10le -pred median -context 1)
            elif [[ "${PIXEL_FORMAT}" = "uyvy422" ]] ; then
                MIDDLEOPTIONS+=(-c:v ffvhuff -pix_fmt yuv422p -pred median -context 1)
            fi
            SUFFIX="_huff" ;;

        # video pixel format and bit depth
        "10 bit") PIXEL_FORMAT="yuv422p10" ;;
        "8 bit")  PIXEL_FORMAT="uyvy422" ;;

        # audio codec
        "24-bit PCM")
            MIDDLEOPTIONS+=(-c:a pcm_s24le) ;;
        "24-bit FLAC")
            MIDDLEOPTIONS+=(-c:a flac) ;;
        "AAC")
            MIDDLEOPTIONS+=(-c:a aac) ;;

        # audio mappings
        "2 Stereo Tracks (Channels 1 & 2 -> 1st Track Stereo, Channels 3 & 4 -> 2nd Track Stereo)")
            AUDIOMAP="[0:a:0]pan=stereo| c0=c0 | c1=${PHASE_VALUE}c1[stereo1];[0:a:0]pan=stereo| c0=c2 | c1=c3[stereo2]"
            AUDIO_CHANNEL_MAP+=(-map "[stereo1]")
            AUDIO_CHANNEL_MAP+=(-map "[stereo2]") ;;
        "1 Stereo Track (From Channels 1 & 2)")
            AUDIOMAP="[0:a:0]pan=stereo| c0=c0 | c1=${PHASE_VALUE}c1[stereo1]"
            AUDIO_CHANNEL_MAP+=(-map "[stereo1]") ;;
        "1 Stereo Track (From Channels 3 & 4)")
            AUDIOMAP="[0:a:0]pan=stereo| c0=c2 | c1=${PHASE_VALUE}c3[stereo1]"
            AUDIO_CHANNEL_MAP+=(-map "[stereo1]") ;;
        "Channel 1 -> 1st Track Mono, Channel 2 -> 2nd Track Mono")
            AUDIOMAP="[0:a:0]pan=mono| c0=c0[mono1];[0:a:0]pan=mono| c0=${PHASE_VALUE}c1[mono2]"
            AUDIO_CHANNEL_MAP+=(-map "[mono1]")
            AUDIO_CHANNEL_MAP+=(-map "[mono2]") ;;
        "Channel 2 -> 1st Track Mono, Channel 1 -> 2nd Track Mono")
            AUDIOMAP="[0:a:0]pan=mono| c0=${PHASE_VALUE}c1[mono1];[0:a:0]pan=mono| c0=c0[mono2]"
            AUDIO_CHANNEL_MAP+=(-map "[mono1]")
            AUDIO_CHANNEL_MAP+=(-map "[mono2]") ;;
        "Channel 1 -> Single Track Mono")
            AUDIOMAP="[0:a:0]pan=mono| c0=c0[mono1]"
            AUDIO_CHANNEL_MAP+=(-map "[mono1]") ;;
        "Channel 2 -> Single Track Mono")
            AUDIOMAP="[0:a:0]pan=mono| c0=c1[mono1]"
            AUDIO_CHANNEL_MAP+=(-map "[mono1]") ;;
        # timecode options
        "none"|"rp188vitc"|"rp188vitc2"|"rp188ltc"|"rp188any"|"vitc"|"vitc2"|"serial")
            TC_TYPE="${1}"
            EXTRAINPUTOPTIONS+=(-timecode_format "${TC_TYPE}")
            MIDDLEOPTIONS+=(-map_metadata 0:s:v:0)
            if [[ "${TC_TYPE}" != "none" ]] ; then
                if [[ "${RUNTYPE}" = "passthrough" ]] ; then
                TIMECODE_OVERLAY=",drawtext=fontfile=${DEFAULTFONT}:x=(w-text_w)*0.5:y=(h-text_h)*0.75:fontcolor=white:box=1:boxcolor=gray@0.7:boxborderw=4:fontsize=22:shadowx=1:shadowy=1:text=%{metadata\\\:timecode\\\:no ${TC_TYPE} timecode}"
                fi
                TC_TMP=$(_maketemp .timecode.txt)
                TC_WRITE=",metadata=mode=print:file=${TC_TMP}"
            fi
            declare TC_TYPE "${TC_TYPE}"
            ;;
        # video standard
        "NTSC")
            STANDARD="ntsc"
            DECKLINK_FPS="30000/1001"
            if [[ "${VIDEO_CODEC_CHOICE}" = "h264" ]] ; then
                RECORDINGFILTER="crop=w=720:h=480:x=0:y=4,setsar=40/27,setdar=4/3"
                MIDDLEOPTIONS+=(-x264opts bff)
            else
                RECORDINGFILTER="setsar=40/27,setdar=4/3"
            fi
            MIDDLEOPTIONS+=(-color_primaries smpte170m)
            MIDDLEOPTIONS+=(-color_trc bt709)
            MIDDLEOPTIONS+=(-colorspace smpte170m) ;;
        "PAL")
            STANDARD="pal "
            DECKLINK_FPS="25000/1000"
            if [[ "${VIDEO_CODEC_CHOICE}" = "h264" ]] ; then
                RECORDINGFILTER="setsar=16/15,setdar=4/3"
                MIDDLEOPTIONS+=(-x264opts tff)
            else
                RECORDINGFILTER="setsar=16/15,setdar=4/3"
            fi
            MIDDLEOPTIONS+=(-color_primaries bt470bg)
            MIDDLEOPTIONS+=(-color_trc bt709)
            MIDDLEOPTIONS+=(-colorspace bt470bg) ;;

        # playback views
        "Unfiltered") PLAYBACKFILTER="" ;;
        "Quality Control View (mpv)") MEDIA_PLAYER_CHOICE="mpv" ;;
        "Audio + Video")
            VECTORSCOPE_FILTER="\
format=yuv422p,\
vectorscope=i=0.04:mode=color2:c=1:envelope=instant:graticule=green:flags=name,\
scale=400:400"
if [[ "${AUDIO_MAPPING_CHOICE}" = '2 Stereo Tracks (Channels 1 & 2 -> 1st Track Stereo, Channels 3 & 4 -> 2nd Track Stereo)' ]] ; then
    PRINT_PHASE=",drawtext=fontfile=${DEFAULTFONT}:box=1: text=Phase\\\: %{metadata\\\:lavfi.aphasemeter.phase}:x=135:y=1 80:fontcolor=black"
    PRINT_CHANNELS_1_2=",drawtext=fontfile=${DEFAULTFONT}: text=Ch.1/2:x=10: y=10:fontcolor=white"
    PRINT_CHANNELS_3_4=",drawtext=fontfile=${DEFAULTFONT}: text=Ch.3/4:x=10: y=10:fontcolor=white"
    AUDIO_SPLIT='7[a][aa][b][c][d][e][out1]'
    CHANNEL_PARAMS="[b]pan=stereo|c0=c0|c1=c1,avectorscope=s=320x400${PRINT_CHANNELS_1_2}[b1],[e]pan=stereo|c0=c2|c1=c3,avectorscope=s=320x400${PRINT_CHANNELS_3_4}[e1]"
    AP_MAP='[phase1][phase2][b1][e1][x][d1][TFIELD][BFIELD][vector]xstack=inputs=9:layout=0_0|0_h0|w0_0|w0+w2_0|w0+w2+w3_0|0_h0+h1|0_h0+h1+h5|w6_h0+h1+h5|w5_h0+h1,fps=25[out0]'
    PHASE_LOCATION='x=135:y=180'
    PHASE_MAP="[a]pan=stereo|c0=c0|c1=c1,aphasemeter=video=0,adrawgraph=lavfi.aphasemeter.phase:max=1:min=-1:size=400x200:bg=black:fg1=0x99999999,drawbox=x=0:y=100:w=400:c=white:h=1${PRINT_PHASE}${PRINT_CHANNELS_1_2}[phase1],\
    [aa]pan=stereo|c0=c2|c1=c3,aphasemeter=video=0,adrawgraph=lavfi.aphasemeter.phase:max=1:min=-1:size=400x200:bg=black:fg1=0x99999999,drawbox=x=0:y=100:w=400:c=white:h=1${PRINT_PHASE}${PRINT_CHANNELS_3_4}[phase2]"
    SPECTRUM_SIZE='755x265'
else
    PRINT_PHASE=",drawtext=fontfile=${DEFAULTFONT}:box=1: text=Phase\\\: %{metadata\\\:lavfi.aphasemeter.phase}:x=135:y=380:fontcolor=black"
    PRINT_CHANNELS_1_2=",drawtext=fontfile=${DEFAULTFONT}: text=Ch.1/2:x=10: y=10:fontcolor=white"
    AUDIO_SPLIT='5[a][b][c][d][out1]'
    CHANNEL_PARAMS="[b]pan=stereo|c0=c0|c1=c1,avectorscope=s=320x400${PRINT_CHANNELS_1_2}[b1]"
    AP_MAP='[a1][b1][x][d1][TFIELD][BFIELD][vector]xstack=inputs=7:layout=0_0|w0_0|w0+w1_0|0_h0+h4|0_h0|w4_h0|w0+w1+w2_0,fps=25[out0]'
    PHASE_LOCATION='x=135:y=380'
    PHASE_MAP="[a]aphasemeter=video=0,adrawgraph=lavfi.aphasemeter.phase:max=1:min=-1:size=320x400:bg=black:fg1=0x99999999,drawbox=x=0:y=200:w=400:c=white:h=1${PRINT_PHASE}${PRINT_CHANNELS_1_2}[a1]"
    SPECTRUM_SIZE='1155x200'
fi
PLAYBACKFILTER="streams=dv+da[vid][aud],[aud]asplit=${AUDIO_SPLIT},\
${PHASE_MAP},\
${CHANNEL_PARAMS},\
[c]showvolume=t=0:h=17:w=200[c1],\
[d]showspectrum=s=${SPECTRUM_SIZE}:fps=10:color=rainbow:saturation=2:legend=1[d1],\
[vid]split=4[vid1][vid2][vid3][vid4],[vid1]scale=400x400,signalstats=out=brng[vidscale],\
[vid2]field=top,${WAVEFORM_FILTER}[TFIELD],\
[vid3]field=bottom,${WAVEFORM_FILTER}[BFIELD],\
[vid4]${VECTORSCOPE_FILTER}[vector],\
[vidscale][c1]overlay=10:10[x],\
${AP_MAP}" ;;
        "Broadcast Range Visual")
            PLAYBACKFILTER="\
${PLAYBACK_FILTER_ADJUSTMENT}split=5[a][b][c][d][e];\
[a]copy${TIMECODE_OVERLAY}[a1];\
[b]field=top,${WAVEFORM_FILTER}[b1];\
[c]field=bottom,${WAVEFORM_FILTER}[c1];\
[d]${VECTORSCOPE_FILTER}[d1];\
[e]scale=512:ih,signalstats=out=brng[e1];\
[a1][b1][c1][e1][d1]xstack=inputs=5:layout=0_0|0_h0|0_h0+h1|w0_0|w0_h0" ;;
        "Full Range Visual")
            PLAYBACKFILTER="\
${PLAYBACK_FILTER_ADJUSTMENT}split=5[a][b][c][d][e];\
[a]copy${TIMECODE_OVERLAY}[a1];\
[b]field=top,${WAVEFORM_FILTER}[b1];\
[c]field=bottom,${WAVEFORM_FILTER}[c1];\
[d]${VECTORSCOPE_FILTER}[d1];\
[e]format=yuv444p,pseudocolor=if(between(1\,val\,amax)+between(val\,254\,amax)\,65\,-1):if(between(1\,val\,amax)+between(val\,254\,amax)\,100\,-1):if(between(1\,val\,amax)+between(val\,254\,amax)\,212\,-1),scale=512:ih[e1];\
[a1][b1][c1][e1][d1]xstack=inputs=5:layout=0_0|0_h0|0_h0+h1|w0_0|w0_h0" ;;
      "Visual + Numerical")
          PLAYBACKFILTER="\
${PLAYBACK_FILTER_ADJUSTMENT}split=6[a][b][c][d][e][f];\
[a]copy${TIMECODE_OVERLAY}[a1];\
[b]field=top,${WAVEFORM_FILTER}[b1];\
[c]field=bottom,${WAVEFORM_FILTER}[c1];\
[d]${VECTORSCOPE_FILTER}[d1];\
[e]signalstats=out=brng:stat=brng+vrep+tout,scale=512:ih,split[e1][e2];\
[e2]format=yuv422p,geq=lum=60:cb=128:cr=128,\
scale=180:ih+512,setsar=1/1,\
drawtext=fontcolor=white:fontsize=22:\
fontfile=${DEFAULTFONT}:textfile=${DRAWTEXT_TMP_1},\
drawtext=fontcolor=white:fontsize=17:\
fontfile=${DEFAULTFONT}:textfile=${DRAWTEXT_TMP_2},\
drawtext=fontcolor=white:fontsize=52:\
fontfile=${DEFAULTFONT}:textfile=${DRAWTEXT_TMP_3}[e3];\
[f]scale=iw+512+180:82,format=yuv422p,geq=lum=60:cb=128:cr=128,drawtext=fontcolor=white:fontsize=22:\
fontfile=${DEFAULTFONT}:textfile=${VRECORD_INPUT_TMP}:\
reload=1:y=82-th[f1];\
[e3][a1][b1][c1][e1][d1][f1]xstack=inputs=7:layout=0_0|w0_0|w0_h1|w0_h1+h2|w0+w1_0|w0+w1_h1|0_h0" ;;
      "Color Matrix")
          HUE=20
          SAT=0.3
          PLAYBACKFILTER="\
${PLAYBACK_FILTER_ADJUSTMENT}scale=iw/4:ih/4,\
split=9[x][hm][hp][sm][sp][hmsm][hmsp][hpsm][hpsp];\
[hm]hue=h=-${HUE}[hm1];\
[hp]hue=h=${HUE}[hp1];\
[sm]hue=s=1-${SAT}[sm1];\
[sp]hue=s=1+${SAT}[sp1];\
[hmsm]hue=h=-${HUE}:s=1-${SAT}[hmsm1];\
[hmsp]hue=h=-${HUE}:s=1+${SAT}[hmsp1];\
[hpsm]hue=h=${HUE}:s=1-${SAT}[hpsm1];\
[hpsp]hue=h=${HUE}:s=1+${SAT}[hpsp1];\
[hpsm1][hp1][hpsp1][sm1][x][sp1][hmsm1][hm1][hmsp1]xstack=inputs=9:layout=0_0|0_h0|0_h0+h1|w0_0|w0_h0|w0_h0+h1|w0+w1_0|w0+w1_h0|w0+w1_h0+h1" ;;
      "Bit Planes")
          if [[ "${PIXEL_FORMAT}" = "uyvy422" ]] ; then
              BITS=8
              SPLIT="8[b0][b1][b2][b3][b4][b5][b6][b7]"
              STACK="[b0c][b1c][b2c][b3c][b4c][b5c][b6c][b7c]hstack=8,format=yuv444p,drawgrid=w=iw/8:h=ih:t=2:c=green@0.5"
          elif [[ "${PIXEL_FORMAT}" = "yuv422p10" ]] ; then
              BITS=10
              SPLIT="10[b0][b1][b2][b3][b4][b5][b6][b7][b8][b9]"
              STACK="\
[b8]bitplanenoise=bitplane=2,crop=iw/10:ih:(iw/10)*8:0,lutyuv=u=(maxval/2):v=(maxval/2):y=bitand(val\\,pow(2\\,10-9))*pow(2\\,9),pad=iw:ih+64:0:64,drawtext=fontfile=${DEFAULTFONT}:text=%{metadata\\\:lavfi.bitplanenoise.0.2}:y=0:fontcolor=white:fontsize=20,drawtext=fontfile=${DEFAULTFONT}:text=%{metadata\\\:lavfi.bitplanenoise.1.2}:y=20:fontcolor=white:fontsize=20,drawtext=fontfile=${DEFAULTFONT}:text=%{metadata\\\:lavfi.bitplanenoise.2.2}:y=40:fontcolor=white:fontsize=20[b8c];\
[b9]bitplanenoise=bitplane=1,crop=iw/10:ih:(iw/10)*9:0,lutyuv=u=(maxval/2):v=(maxval/2):y=bitand(val\\,pow(2\\,10-10))*pow(2\\,10),pad=iw:ih+64:0:64,drawtext=fontfile=${DEFAULTFONT}:text=%{metadata\\\:lavfi.bitplanenoise.0.1}:y=0:fontcolor=silver:fontsize=20,drawtext=fontfile=${DEFAULTFONT}:text=%{metadata\\\:lavfi.bitplanenoise.1.1}:y=20:fontcolor=silver:fontsize=20,drawtext=fontfile=${DEFAULTFONT}:text=%{metadata\\\:lavfi.bitplanenoise.2.1}:y=40:fontcolor=silver:fontsize=20[b9c];\
[b0c][b1c][b2c][b3c][b4c][b5c][b6c][b7c][b8c][b9c]hstack=10,format=yuv444p,drawgrid=w=iw/10:h=ih:t=2:c=green@0.5"
          fi
          PLAYBACKFILTER="\
${PLAYBACK_FILTER_ADJUSTMENT}format=yuv420p10le|yuv422p10le|yuv444p10le|yuv440p10le,split=${SPLIT};\
[b0]bitplanenoise=bitplane=10,crop=iw/${BITS}:ih:(iw/${BITS})*0:0,lutyuv=u=(maxval/2):v=(maxval/2):y=bitand(val\\,pow(2\\,10-1))*pow(2\\,1),pad=iw:ih+64:0:64,drawtext=fontfile=${DEFAULTFONT}:text=%{metadata\\\:lavfi.bitplanenoise.0.10}:y=0:fontcolor=white:fontsize=20,drawtext=fontfile=${DEFAULTFONT}:text=%{metadata\\\:lavfi.bitplanenoise.1.10}:y=20:fontcolor=white:fontsize=20,drawtext=fontfile=${DEFAULTFONT}:text=%{metadata\\\:lavfi.bitplanenoise.2.10}:y=40:fontcolor=white:fontsize=20[b0c];\
[b1]bitplanenoise=bitplane=9,crop=iw/${BITS}:ih:(iw/${BITS})*1:0,lutyuv=u=(maxval/2):v=(maxval/2):y=bitand(val\\,pow(2\\,10-2))*pow(2\\,2),pad=iw:ih+64:0:64,drawtext=fontfile=${DEFAULTFONT}:text=%{metadata\\\:lavfi.bitplanenoise.0.9}:y=0:fontcolor=silver:fontsize=20,drawtext=fontfile=${DEFAULTFONT}:text=%{metadata\\\:lavfi.bitplanenoise.1.9}:y=20:fontcolor=silver:fontsize=20,drawtext=fontfile=${DEFAULTFONT}:text=%{metadata\\\:lavfi.bitplanenoise.2.9}:y=40:fontcolor=silver:fontsize=20[b1c];\
[b2]bitplanenoise=bitplane=8,crop=iw/${BITS}:ih:(iw/${BITS})*2:0,lutyuv=u=(maxval/2):v=(maxval/2):y=bitand(val\\,pow(2\\,10-3))*pow(2\\,3),pad=iw:ih+64:0:64,drawtext=fontfile=${DEFAULTFONT}:text=%{metadata\\\:lavfi.bitplanenoise.0.8}:y=0:fontcolor=white:fontsize=20,drawtext=fontfile=${DEFAULTFONT}:text=%{metadata\\\:lavfi.bitplanenoise.1.8}:y=20:fontcolor=white:fontsize=20,drawtext=fontfile=${DEFAULTFONT}:text=%{metadata\\\:lavfi.bitplanenoise.2.8}:y=40:fontcolor=white:fontsize=20[b2c];\
[b3]bitplanenoise=bitplane=7,crop=iw/${BITS}:ih:(iw/${BITS})*3:0,lutyuv=u=(maxval/2):v=(maxval/2):y=bitand(val\\,pow(2\\,10-4))*pow(2\\,4),pad=iw:ih+64:0:64,drawtext=fontfile=${DEFAULTFONT}:text=%{metadata\\\:lavfi.bitplanenoise.0.7}:y=0:fontcolor=silver:fontsize=20,drawtext=fontfile=${DEFAULTFONT}:text=%{metadata\\\:lavfi.bitplanenoise.1.7}:y=20:fontcolor=silver:fontsize=20,drawtext=fontfile=${DEFAULTFONT}:text=%{metadata\\\:lavfi.bitplanenoise.2.7}:y=40:fontcolor=silver:fontsize=20[b3c];\
[b4]bitplanenoise=bitplane=6,crop=iw/${BITS}:ih:(iw/${BITS})*4:0,lutyuv=u=(maxval/2):v=(maxval/2):y=bitand(val\\,pow(2\\,10-5))*pow(2\\,5),pad=iw:ih+64:0:64,drawtext=fontfile=${DEFAULTFONT}:text=%{metadata\\\:lavfi.bitplanenoise.0.6}:y=0:fontcolor=white:fontsize=20,drawtext=fontfile=${DEFAULTFONT}:text=%{metadata\\\:lavfi.bitplanenoise.1.6}:y=20:fontcolor=white:fontsize=20,drawtext=fontfile=${DEFAULTFONT}:text=%{metadata\\\:lavfi.bitplanenoise.2.6}:y=40:fontcolor=white:fontsize=20[b4c];\
[b5]bitplanenoise=bitplane=5,crop=iw/${BITS}:ih:(iw/${BITS})*5:0,lutyuv=u=(maxval/2):v=(maxval/2):y=bitand(val\\,pow(2\\,10-6))*pow(2\\,6),pad=iw:ih+64:0:64,drawtext=fontfile=${DEFAULTFONT}:text=%{metadata\\\:lavfi.bitplanenoise.0.5}:y=0:fontcolor=silver:fontsize=20,drawtext=fontfile=${DEFAULTFONT}:text=%{metadata\\\:lavfi.bitplanenoise.1.5}:y=20:fontcolor=silver:fontsize=20,drawtext=fontfile=${DEFAULTFONT}:text=%{metadata\\\:lavfi.bitplanenoise.2.5}:y=40:fontcolor=silver:fontsize=20[b5c];\
[b6]bitplanenoise=bitplane=4,crop=iw/${BITS}:ih:(iw/${BITS})*6:0,lutyuv=u=(maxval/2):v=(maxval/2):y=bitand(val\\,pow(2\\,10-7))*pow(2\\,7),pad=iw:ih+64:0:64,drawtext=fontfile=${DEFAULTFONT}:text=%{metadata\\\:lavfi.bitplanenoise.0.4}:y=0:fontcolor=white:fontsize=20,drawtext=fontfile=${DEFAULTFONT}:text=%{metadata\\\:lavfi.bitplanenoise.1.4}:y=20:fontcolor=white:fontsize=20,drawtext=fontfile=${DEFAULTFONT}:text=%{metadata\\\:lavfi.bitplanenoise.2.4}:y=40:fontcolor=white:fontsize=20[b6c];\
[b7]bitplanenoise=bitplane=3,crop=iw/${BITS}:ih:(iw/${BITS})*7:0,lutyuv=u=(maxval/2):v=(maxval/2):y=bitand(val\\,pow(2\\,10-8))*pow(2\\,8),pad=iw:ih+64:0:64,drawtext=fontfile=${DEFAULTFONT}:text=%{metadata\\\:lavfi.bitplanenoise.0.3}:y=0:fontcolor=silver:fontsize=20,drawtext=fontfile=${DEFAULTFONT}:text=%{metadata\\\:lavfi.bitplanenoise.1.3}:y=20:fontcolor=silver:fontsize=20,drawtext=fontfile=${DEFAULTFONT}:text=%{metadata\\\:lavfi.bitplanenoise.2.3}:y=40:fontcolor=silver:fontsize=20[b7c];\
${STACK}" ;;

        # others
        "Yes"|"Yes, after recording"|"Yes, concurrent with recording"|"No") ;;
        *)           _report -w "Error: ${1} is not a valid option." ; return 1 ;;
    esac
}

_frames_to_hhmmss(){
    H=$(echo "${i} / (60 * 60 * ${DECKLINK_FPS})" | bc)
    M=$(echo "(${i} - (${H}*60 * 60 * ${DECKLINK_FPS})) / (60 * ${DECKLINK_FPS})" | bc)
    S="$(echo "scale=3;(${i} - (${H}*60 * 60 * ${DECKLINK_FPS})-($M*60*${DECKLINK_FPS})) / (${DECKLINK_FPS})" | bc)"
    Ss=$(echo "${S}" | cut -d. -f1 | bc)
    Sm=$(echo "${S}" | cut -d. -f2 | bc)
    printf "%02d:%02d:%02d.%03d\n" "${H}" "${M}" "${Ss}" "${Sm}"
}

# set up drawtext.txt files for Visual + Numerical playback view

DRAWTEXT_TMP_1="$(_maketemp .drawtext.1.txt)"
DRAWTEXT_TMP_2="$(_maketemp .drawtext.2.txt)"
DRAWTEXT_TMP_3="$(_maketemp .drawtext.3.txt)"

_set_up_drawtext(){
    echo -e "%{pts:hms}

  Y
 Low  %{metadata:lavfi.signalstats.YLOW}
 Avg  %{metadata:lavfi.signalstats.YAVG}
 High %{metadata:lavfi.signalstats.YHIGH}
 Diff %{metadata:lavfi.signalstats.YDIF}

  U
 Low  %{metadata:lavfi.signalstats.ULOW}
 Avg  %{metadata:lavfi.signalstats.UAVG}
 High %{metadata:lavfi.signalstats.UHIGH}
 Diff %{metadata:lavfi.signalstats.UDIF}

  V
 Low  %{metadata:lavfi.signalstats.VLOW}
 Avg  %{metadata:lavfi.signalstats.VAVG}
 High %{metadata:lavfi.signalstats.VHIGH}
 Diff %{metadata:lavfi.signalstats.VDIF}

  SAT
 Low  %{metadata:lavfi.signalstats.SATLOW}
 Avg  %{metadata:lavfi.signalstats.SATAVG}
 High %{metadata:lavfi.signalstats.SATHIGH}
 " > "${DRAWTEXT_TMP_1}"

    echo -e "































 HUE(med) %{metadata:lavfi.signalstats.HUEMED}
 HUE(avg) %{metadata:lavfi.signalstats.HUEAVG}
 TOUT     %{metadata:lavfi.signalstats.TOUT}
 VREP     %{metadata:lavfi.signalstats.VREP}


" > "${DRAWTEXT_TMP_2}"
    echo -e "

















BRNG
%{metadata:lavfi.signalstats.BRNG}
" > "${DRAWTEXT_TMP_3}"
}

# select playback view
WAVEFORM_FILTER="\
format=yuv422p,\
waveform=intensity=0.1:mode=column:mirror=1:c=1:f=lowpass:e=instant:graticule=green:flags=numbers+dots"
VECTORSCOPE_FILTER="\
format=yuv422p,\
vectorscope=i=0.04:mode=color2:c=1:envelope=instant:graticule=green:flags=name,\
scale=512:512,\
drawbox=w=9:h=9:t=1:x=128-3:y=512-452-5:c=sienna@0.8,\
drawbox=w=9:h=9:t=1:x=160-3:y=512-404-5:c=sienna@0.8,\
drawbox=w=9:h=9:t=1:x=192-3:y=512-354-5:c=sienna@0.8,\
drawbox=w=9:h=9:t=1:x=224-3:y=512-304-5:c=sienna@0.8,\
drawgrid=w=32:h=32:t=1:c=white@0.1,\
drawgrid=w=256:h=256:t=1:c=white@0.2"

# list of selections for each vrecord option
VIDEO_INPUT_OPTIONS=("Composite" "SDI" "Component" "S-Video")
AUDIO_INPUT_OPTIONS=("Analog" "SDI Embedded Audio" "Digital Audio (AES/EBU)")
CONTAINER_OPTIONS=("QuickTime" "Matroska" "AVI" "MXF" "MP4")
VIDEO_CODEC_OPTIONS=("Uncompressed Video" "FFV1 version 3" "JPEG2000" "ProRes" "ProRes (HQ)" "h264" "HuffYUV")
FFV1_SLICE_OPTIONS=("4" "6" "9" "12" "16" "24" "30")
AUDIO_CODEC_OPTIONS=("24-bit PCM" "24-bit FLAC" "AAC")
VIDEO_BITDEPTH_OPTIONS=("10 bit" "8 bit")
CHANNEL_MAPPING_OPTIONS=("2 Stereo Tracks (Channels 1 & 2 -> 1st Track Stereo, Channels 3 & 4 -> 2nd Track Stereo)" "1 Stereo Track (From Channels 1 & 2)" "1 Stereo Track (From Channels 3 & 4)" "Channel 1 -> 1st Track Mono, Channel 2 -> 2nd Track Mono" "Channel 2 -> 1st Track Mono, Channel 1 -> 2nd Track Mono" "Channel 1 -> Single Track Mono" "Channel 2 -> Single Track Mono")
TIMECODE_OPTIONS=("none" "rp188vitc" "rp188vitc2" "rp188ltc" "rp188any" "vitc" "vitc2" "serial")
STANDARD_OPTIONS=("NTSC" "PAL")
QCTOOLSXML_OPTIONS=("Yes, after recording" "Yes, concurrent with recording" "No")
FRAMEMD5_OPTIONS=("Yes" "No")
EMBED_LOGS_OPTIONS=("Yes" "No")
DURATION_OPTIONS=(23 33 63 93)
PLAYBACKVIEW_OPTIONS=("Unfiltered" "Quality Control View (mpv)" "Broadcast Range Visual" "Full Range Visual" "Visual + Numerical" "Color Matrix" "Bit Planes")
PLAYBACKVIEW_PASS_OPTIONS=("Unfiltered" "Quality Control View (mpv)" "Broadcast Range Visual" "Audio + Video" "Full Range Visual" "Visual + Numerical" "Color Matrix" "Bit Planes")


# GUI mode + CLI reset, edit modes
if [[ "${RUNTYPE}" = "GUI" ]] ; then
    _home_gui
fi
if [[ "${RUNTYPE}" = "reset" ]] ; then
    _report -q -n "Resetting the configuration will clear ${CONFIG_FILE}. Please enter [Y] to confirm: "
    read RESET_RESPONSE
    if [[ "${RESET_RESPONSE}" = [Yy] ]] ; then
        _report -d "Clearing ${CONFIG_FILE}."
        echo -n "" > "${CONFIG_FILE}"
        RUNTYPE="edit"
    else
        _report -d "Reset aborted. Exiting."
        exit 0
    fi
fi
while [[ "${RUNTYPE}" = "edit" ]] ; do
    _edit_mode
done

if [[ "${INVERT_PHASE}" = 'true' ]] ; then
    PHASE_VALUE="-1*"
fi

_review_option(){
    unset NO_LOOKUP
    OPTIND=1
    while getopts "n" opt ; do
        case "${opt}" in
            n) NO_LOOKUP="Y" #also the SELECTED value to be used as-is rather than lookup what it means
        esac
    done
    shift "$((OPTIND-1))"
    VALUE_NAME="${1}"
    SELECTED="${!1}"
    QUERY="${2}"
    shift 2
    CHOICES=("${@}")
    if [[ "${SELECTED}" ]] ; then
        if [[ "${NO_LOOKUP}" != "Y" ]] ; then
          _lookup_choice "${SELECTED}"
        fi
        LOG_OF_OPTIONS+="${VALUE_NAME}: ${SELECTED}\n"
        OPTION="${SELECTED}"
    else
        _report -q "${QUERY}"
        PS3="Select an option or 'q' to quit: "
        select OPTION in "${CHOICES[@]}" ; do
            if [[ "${NO_LOOKUP}" != "Y" ]] ; then
              _lookup_choice "${OPTION}" "${REPLY}"
            fi
            [[ "${?}" -eq 0 ]] && break
        done
        export "${VALUE_NAME}"="${OPTION}"
        LOG_OF_OPTIONS+="${VALUE_NAME}: ${OPTION}\n"
    fi
}

if [[ "${DEVICE_INPUT_CHOICE}" = "0" ]] ; then
    _review_option "VIDEO_INPUT_CHOICE" "Which video input are you using?" "${VIDEO_INPUT_OPTIONS[@]}"
    _review_option "AUDIO_INPUT_CHOICE" "Which audio input are you using?" "${AUDIO_INPUT_OPTIONS[@]}"
    _review_option "VIDEO_BIT_DEPTH_CHOICE" "Which video bit depth?" "${VIDEO_BITDEPTH_OPTIONS[@]}"
    _review_option "AUDIO_MAPPING_CHOICE" "Which audio mapping?" "${CHANNEL_MAPPING_OPTIONS[@]}"
    if [[ -z "${ALT_INPUT}" ]] ; then
        _review_option "TIMECODE_CHOICE" "Which timecode format?" "${TIMECODE_OPTIONS[@]}"
    fi
    _review_option "STANDARD_CHOICE" "Which television STANDARD?" "${STANDARD_OPTIONS[@]}"
elif [[ "${DEVICE_INPUT_CHOICE}" = "1" ]] ; then
    _review_option -n "AVF_INPUT_CHOICE" "Which avfoundation input are you using?" "${AVFOUNDATION_DEVICES[@]}"
fi
if [[ "${CORE_COUNT}" -le 2 && "${RUNTYPE}" = "record" ]] ; then
    _report -w "Since this computer has only ${CORE_COUNT} cores, the playback will display only half of the frames to reduce CPU. This will not impact the recording."
    PLAYBACK_FILTER_ADJUSTMENT="select=not(mod(n\,2)),"
fi
if [[ "${RUNTYPE}" = "passthrough" ]] && [[ -n "${PLAYBACKVIEW_CHOICE_PASS}" ]] && [[ "${PLAYBACKVIEW_CHOICE_PASS}" != "Unselected" ]] ; then
  _review_option "PLAYBACKVIEW_CHOICE_PASS" "Which playback view?" "${PLAYBACKVIEW_OPTIONS[@]}"
else
  _review_option "PLAYBACKVIEW_CHOICE" "Which playback view?" "${PLAYBACKVIEW_OPTIONS[@]}"
fi
if [[ "${DEVICE_INPUT_CHOICE}" = 0 ]] ; then
  if [[ "${OPTION}" = "Full Range Visual" ]] ; then
      MIDDLEOPTIONS+=(-color_range jpeg)
  else
      MIDDLEOPTIONS+=(-color_range mpeg)
  fi

  MIDDLEOPTIONS+=(-metadata creation_time=now)
fi
MIDDLEOPTIONS+=(${EXTRAOUTPUTOPTIONS[@]})

# set up input and playback
_set_up_drawtext
if [[ "$VERBOSE" = "true" ]] ; then
    GRAB_INPUT=(-loglevel debug)
    _report -wt "When running vrecord in verbose mode, avoid using Visual + Numerical option."
else
    GRAB_INPUT=(-loglevel info)
fi
if [[ -n "${ALT_INPUT}" ]] ; then
    GRAB_INPUT+=("${EXTRAINPUTOPTIONS[@]}")
    GRAB_INPUT+=(-i "${ALT_INPUT}")
elif [[ "${DEVICE_INPUT_CHOICE}" = 0 && "${FFMPEG_DECKLINK_SUPPORT}" = "N" ]] ; then
    echo "vrecord is set to use a decklink input but ${FFMPEG_BIN} does not appear to support decklink inputs."
    echo "Please review installation and troubleshooting information for vrecord or install ffmpegdecklink."
    exit 1
elif [[ "${DEVICE_INPUT_CHOICE}" = 0 && ! "${FFMPEG_DECKLINK_SUPPORT}" = "N" ]] ; then
    GRAB_INPUT+=(-f decklink)
    GRAB_INPUT+=(-draw_bars 0)
    GRAB_INPUT+=(-audio_input "${AUDIO_INPUT}")
    GRAB_INPUT+=(-video_input "${VIDEO_INPUT}")
    GRAB_INPUT+=(-format_code "${STANDARD}")
    GRAB_INPUT+=(-channels 8)
    GRAB_INPUT+=(-audio_depth 32)
    GRAB_INPUT+=(-raw_format "${PIXEL_FORMAT}")
    GRAB_INPUT+=("${EXTRAINPUTOPTIONS[@]}")
    GRAB_INPUT+=(-i "${DECKLINK_INPUT_CHOICE}")
elif [[ "${DEVICE_INPUT_CHOICE}" = 1 ]] ; then
    GRAB_INPUT+=(-f avfoundation)
    GRAB_INPUT+=(-capture_raw_data true)
    GRAB_INPUT+=(-drop_late_frames false)
    GRAB_INPUT+=("${EXTRAINPUTOPTIONS[@]}")
    GRAB_INPUT+=(-i "${AVF_INPUT_CHOICE}:none")
    MIDDLEOPTIONS+=(-c copy -map 0)
    EXTENSION="dv"
    FORMAT="rawvideo"
else
    _report "Input unknown"
    exit 1
fi

if [[ "${DEVICE_INPUT_CHOICE}" = 0 ]] ; then
    PIPE_OUTPUT=(-c copy)
    PIPE_OUTPUT+=(-map 0)
    PIPE_OUTPUT+=(-f matroska)
    PIPE_OUTPUT+=(-write_crc32 0)
    PIPE_OUTPUT+=(-live true)
    PIPE_OUTPUT+=(-)
    WINDOW_NAME="mode:${RUNTYPE} - video:'${VIDEO_INPUT}' audio:'${AUDIO_INPUT}' - to end recording press q, esc, or close video window"
elif [[ "${DEVICE_INPUT_CHOICE}" = 1 ]] ; then
    PIPE_OUTPUT=(-c copy)
    PIPE_OUTPUT+=(-map 0)
    PIPE_OUTPUT+=(-f rawvideo)
    PIPE_OUTPUT+=(-)
    WINDOW_NAME="mode:${RUNTYPE} - input:'${AVF_INPUT_CHOICE}' - to end recording press q, esc, or close video window"
else
    _report "Input unknown"
    exit 1
fi

_set_ffplay_options(){
    FFPLAY_OPTIONS=(-v info)
    FFPLAY_OPTIONS+=(-hide_banner)
    FFPLAY_OPTIONS+=(-stats)
    FFPLAY_OPTIONS+=(-autoexit)
    if [[ "${RUNTYPE}" = "passthrough" ]] ; then
        FFPLAY_OPTIONS+=("${GRAB_INPUT[@]}")
    else
        FFPLAY_OPTIONS+=(-i -)
    fi
    FFPLAY_OPTIONS+=(-window_title "${WINDOW_NAME}")
    if [[ ! -z "${PLAYBACKFILTER}" ]] ; then
        FFPLAY_OPTIONS+=(-vf "${PLAYBACKFILTER}")
    fi
    FFPLAY_OPTIONS+=(-af "channelmap=0|1:stereo")
}

# CLI passthrough and audiopassthrough modes
if [[ "${RUNTYPE}" = "passthrough" ]] ; then
    _passthrough_mode
elif [[ "${RUNTYPE}" = "audiopassthrough" ]] ; then
    _audiopassthrough_mode
fi

# GUI mode loops
while [[ "${GUI}" = 1 ]] && [[ "${RUNTYPE}" != "record" ]] ; do
    if [[ "${RUNTYPE}" = "passthrough" ]] ; then
        _passthrough_mode
    elif [[ "${RUNTYPE}" = "audiopassthrough" ]] ; then
        _audiopassthrough_mode
    elif [[ "${RUNTYPE}" = "edit" ]] ; then
        _edit_mode
    fi
done

# record mode
while [[ -z "${ID}" ]] ; do
    _report -q -n "Enter ${AHEM}Identifier: "
    read ID
    if [[ "${ID}" = "q" ]] ; then
        _report -w "Interpreting 'q' to quit."
        exit 1
    fi
    AHEM="a (non-blank) "
done
if [[ ! -d "${DIR}" ]] ; then
    _report -q -n "Enter Directory: "
    read DIR
    DIR="$(echo "${DIR}" | sed "s/^['\"]\(.*\).$/\1/")"
    if [[ ! -d "${DIR}" ]] ; then
        _report -w "Error: Not a valid directory"
        exit 1
    fi
fi

if [[ ! -d "${LOGDIR}" ]] ; then
    if [[ ! -d "${DIR}" ]] ; then
        _report -q -n "Enter Directory for Auxiliary Files (If blank will default to recording directory): "
        read LOGDIR
        LOGDIR="$(echo "${LOGDIR}" | sed "s/^['\"]\(.*\).$/\1/")"
    else
        LOGDIR="${DIR}"
    fi
    if [[ ! -d "${LOGDIR}" ]] ; then
        _report -w "Error: Not a valid directory"
        exit 1
    fi
fi

if [[ "${DEVICE_INPUT_CHOICE}" = "0" ]] ; then
    _review_option "CONTAINER_CHOICE" "Which audiovisual container format?" "${CONTAINER_OPTIONS[@]}"
    _review_option "VIDEO_CODEC_CHOICE" "Which video codec?" "${VIDEO_CODEC_OPTIONS[@]}"
    if [[ "${VIDEO_CODEC_CHOICE}" = "FFV1 version 3" ]] ; then
        _review_option -n "FFV1_SLICE_CHOICE" "FFV1 Slice Count?" "${FFV1_SLICE_OPTIONS[@]}"
    fi
    _review_option "AUDIO_CODEC_CHOICE" "Which audio codec?" "${AUDIO_CODEC_OPTIONS[@]}"
fi

# Check for user suffix to override automatic settings

if [[ -n "${USER_SUFFIX}" ]] ; then
    SUFFIX="${USER_SUFFIX}"
elif [[ "${NO_SUFFIX}" = 'true' ]] ; then
    SUFFIX=''
fi

FULL_OUTPUT_ID="${PREFIX}${ID}${SUFFIX}"
FULL_CAPTURE_LOG="${LOGDIR}/${FULL_OUTPUT_ID}${CAPTURELOGSUFFIX}"

VRECORD_OUTPUT="${DIR}/${FULL_OUTPUT_ID}.${EXTENSION}"
if [[ -f "${VRECORD_OUTPUT}" ]] ; then
    _report -w "A file called ${VRECORD_OUTPUT} already exists."
    _report -w "Exiting to avoid overwriting that file."
    exit
fi

_review_option "QCTOOLSXML_CHOICE" "Create QCTools XML?" "${QCTOOLSXML_OPTIONS[@]}"
if [[ "${OPTION}" != "No" && ! "$(command -v qcli)" ]] ; then
    _report -w "Please install qcli to use the qctools reporting option."
    _report -w "Such as \`brew install qcli\`."
    exit 1
fi
_review_option "FRAMEMD5_CHOICE" "Create frame-level MD5 checksums?" "${FRAMEMD5_OPTIONS[@]}"
if [[ "${OPTION}" = "Yes" ]] ; then
    FRAMEMD5NAME="${LOGDIR}/${FULL_OUTPUT_ID}.framemd5"
    EXTRAOUTPUTS=(-an -f framemd5 "${FRAMEMD5NAME}")
fi
if [[ "${FORMAT}" = "matroska" ]] ; then
    _review_option "EMBED_LOGS_CHOICE" "Embed logs in Matroska file?" "${EMBED_LOGS_OPTIONS[@]}"
fi

_duration_check
if [[ -n "${DURATION}" ]] ; then
    DUR_SECONDS=$(bc <<< "${DURATION} * 60" | sed "s/^\./0./")
    INPUTOPTIONS+=(-t "${DUR_SECONDS}")
fi

if [[ -z "${TECHNICIAN}" ]] ; then
    _report -q -n "Enter the name of the person digitizing the tape or leave blank: "
    read TECHNICIAN
fi

if [[ "${DEVICE_INPUT_CHOICE}" = "0" ]] ; then
    _report -d "Summary: ${VIDEOCODECNAME}/${FORMAT} ${PIXEL_FORMAT} file from ${STANDARD} ${VIDEO_INPUT} ${AUDIO_INPUT}. Frame MD5s=${FRAMEMD5_CHOICE}, QCTools XML=${QCTOOLSXML_CHOICE}, and Technician=${TECHNICIAN}. Inputs recorded to ${VRECORD_OUTPUT} and Auxiliary Files created in ${LOGDIR}"
elif [[ "${DEVICE_INPUT_CHOICE}" = "1" ]] ; then
    _report -d "Summary: Copying video from ${AVF_INPUT_CHOICE}. Frame MD5s=${FRAMEMD5_CHOICE}, QCTools XML=${QCTOOLSXML_CHOICE}, and Technician=${TECHNICIAN}. Inputs recorded to ${VRECORD_OUTPUT} and Auxiliary Files created in ${LOGDIR}"
fi

if [[ "${INVERT_PHASE}" = 'true' ]] ; then
    echo -e " \033[101mWARNING: Option to invert phase of second audio channel has been selected\033[0m"
fi
_report -q "Hit enter to start recording"
read

# create log of vrecord decisions
INGESTLOG="${LOGDIR}/${FULL_OUTPUT_ID}_capture_options.log"
QCXML="${LOGDIR}/${FULL_OUTPUT_ID}.${EXTENSION}.qctools.xml.gz"
touch "${INGESTLOG}"
_writeingestlog "computer_name" "$(uname -n)"
_writeingestlog "computer_model_name" "$(_parse_report "Model Name" "${HARDWARE_REPORT}")"
if [[ "${OS_TYPE}" = "macOS" ]] ; then
    _writeingestlog "computer_model_id" "$(_parse_report "Model Identifier" "${HARDWARE_REPORT}")"
    _writeingestlog "computer_processor_name" "$(_parse_report "Processor Name" "${HARDWARE_REPORT}")"
    _writeingestlog "computer_processor_speed" "$(_parse_report "Processor Speed" "${HARDWARE_REPORT}")"
    _writeingestlog "computer_processor_count" "$(_parse_report "Number of Processors" "${HARDWARE_REPORT}")"
    _writeingestlog "computer_memory" "$(_parse_report "Memory" "${HARDWARE_REPORT}")"
    _writeingestlog "computer_serial" "$(_parse_report "Serial Number (system)" "${HARDWARE_REPORT}")"
fi
_writeingestlog "computer_cores" "$CORE_COUNT"
_writeingestlog "user_name" "$(whoami)"
_writeingestlog "operating_system_VERSION" "$(uname -v)"
_writeingestlog "vrecord version" "${VERSION}"
_writeingestlog "datetime_start" "$(_get_iso8601)"

MOUNT_PATH="$(df -Ph "${DIR}" | tail -n 1 | awk '{print $6}')"
if [[ "${OS_TYPE}" = "macOS" ]] ; then
    VOLUME_INFO="$(diskutil info "${MOUNT_PATH}")"
    PART_OF_WHOLE="/dev/$(_parse_report "Part of Whole" "${VOLUME_INFO}")"
    CAPTURE_DEVICE_INFO="$(diskutil info "${PART_OF_WHOLE}")"

    _writeingestlog "capture_device_node" "$(_parse_report "Device Node" "${CAPTURE_DEVICE_INFO}")"
    _writeingestlog "capture_device_protocol" "$(_parse_report "Protocol" "${CAPTURE_DEVICE_INFO}")"
    _writeingestlog "capture_device_name" "$(_parse_report "Device / Media Name" "${CAPTURE_DEVICE_INFO}")"
    _writeingestlog "capture_device_block_size" "$(_parse_report "Device Block Size" "${CAPTURE_DEVICE_INFO}")"
    _writeingestlog "capture_device_location" "$(_parse_report "Device Location" "${CAPTURE_DEVICE_INFO}")"
    _writeingestlog "capture_device_partition_type" "$(_parse_report "Partition Type" "${VOLUME_INFO}")"
    _writeingestlog "capture_device_partition_name" "$(_parse_report "Name (User Visible)" "${VOLUME_INFO}")"
    _writeingestlog "capture_device_volume_uuid" "$(_parse_report "Volume UUID" "${VOLUME_INFO}")"
    _writeingestlog "capture_device_volume_available" "$(_parse_report "Volume Available Space" "${VOLUME_INFO}")"
    _writeingestlog "capture_device_volume_total" "$(_parse_report "Volume Total Space" "${VOLUME_INFO}")"
fi

_writeingestlog "FILE_PATH" "${VRECORD_OUTPUT}"

if [[ "${DEVICE_INPUT_CHOICE}" = 0 ]] ; then
    if [[ -n "${VIDEO_CARD_DRIVER_VERSION}" ]] ; then
        _writeingestlog "video_card_driver_version" "${VIDEO_CARD_DRIVER_VERSION}"
    fi
    _writeingestlog "video_card_name" "${DECKLINK_INPUT_CHOICE}"
elif [[ "${DEVICE_INPUT_CHOICE}" = 1 ]] ; then
    _writeingestlog "avfoundation_input" "${AVF_INPUT_CHOICE}"
fi

echo -e "${LOG_OF_OPTIONS}" >> "${INGESTLOG}"
if [[ -z "${TECHNICIAN}" ]] ; then
    _writeingestlog "TECHNICIAN" "N/A"
else
    _writeingestlog "TECHNICIAN" "${TECHNICIAN}"
fi
if [[ "${INVERT_PHASE}" = 1 ]] ; then
    _writeingestlog "INVERT_PHASE" "Yes"
fi
if [[ -n "${EXTRAINPUTOPTIONS[@]}" ]] ; then
    _writeingestlog "EXTRA_INPUT_OPTIONS" "${EXTRAINPUTOPTIONS[@]}"
fi
if [[ -n "${EXTRAOUTPUTOPTIONS[@]}" ]] ; then
    _writeingestlog "EXTRA_OUTPUT_OPTIONS" "${EXTRAOUTPUTOPTIONS[@]}"
fi

_report -d "Close the playback window to stop recording."

# vrecord process!
RECORD_COMMAND=("${FFMPEG_BIN}")
RECORD_COMMAND+=(-nostdin -nostats "${INPUTOPTIONS[@]}" "${GRAB_INPUT[@]}")
if [[ -n "${VIDEOCODECNAME}" ]] ; then
    MIDDLEOPTIONS+=(-metadata:s:v:0 encoder="${VIDEOCODECNAME}")
fi
RECORD_COMMAND+=("${MIDDLEOPTIONS[@]}")
if [[ "${DEVICE_INPUT_CHOICE}" = 0 ]] ; then
    # DEVICE_INPUT_CHOICE=0 is decklink, other DEVICE_INPUT_CHOICE values don't yet use such filtering
    RECORD_COMMAND+=(-filter_complex "[0:v:0]${RECORDINGFILTER}${TC_WRITE}; ${AUDIOMAP}" "${AUDIO_CHANNEL_MAP[@]}")
fi
RECORD_COMMAND+=(-f "${FORMAT}" "${VRECORD_OUTPUT}")
RECORD_COMMAND+=("${EXTRAOUTPUTS[@]}" "${PIPE_OUTPUT[@]}")
_writeingestlog "FFmpeg command" "${RECORD_COMMAND[@]}"
_set_ffplay_options
if [[ "${MEDIA_PLAYER_CHOICE}" = "mpv" ]] ; then
    _check_mpv
    "${RECORD_COMMAND[@]}" \
        2> >(tee "${FULL_CAPTURE_LOG}" "${VRECORD_INPUT_TMP}" 1>&2) \
        | \
        if [[ "${QCTOOLSXML_CHOICE}" = "Yes, concurrent with recording" ]] ; then
            tee >(mpv "${MPVOPTS[@]}" --title="${WINDOW_NAME}" -) | \
                qcli -f signalstats+aphasemeter+astats+ssim -i - -o "${QCXML}"
        else
            mpv "${MPVOPTS[@]}" --title="${WINDOW_NAME}" -
        fi
else
    "${RECORD_COMMAND[@]}" \
        2> >(tee "${FULL_CAPTURE_LOG}" "${VRECORD_INPUT_TMP}" 1>&2) \
        | \
        if [[ "${QCTOOLSXML_CHOICE}" = "Yes, concurrent with recording" ]] ; then
            tee >("${FFPLAY_BIN}" "${FFPLAY_OPTIONS[@]}") | \
                qcli -f signalstats+aphasemeter+astats+ssim -i - -o "${QCXML}"
        else
            "${FFPLAY_BIN}" "${FFPLAY_OPTIONS[@]}"
        fi
fi
# capture errors from components of recording pipe
P1_ERR="${PIPESTATUS[0]}"
P2_ERR="${PIPESTATUS[1]}"
P3_ERR="${PIPESTATUS[2]}"

if [[ ! -s "${VRECORD_OUTPUT}" ]] ; then
    if [[ "$P1_ERR" != "0" ]] ; then
        _report -wts "Error: Running: ${RECORD_COMMAND[@]} gave an Error Code - ${P1_ERR}"
        _report -w "Consider reporting this or asking for help at https://github.com/amiaopensource/vrecord/issues"
        _writeingestlog "FFmpeg command Error" "${P1_ERR}"
        exit 1
    fi
    if [[ "$P2_ERR" != "0" && ! -z "$P2_ERR" ]] ; then
        _report -wts "Error: The second component of vrecord recording process gave an Error Code - ${P2_ERR}"
        _report -w "Consider reporting this or asking for help at https://github.com/amiaopensource/vrecord/issues"
        _writeingestlog "vrecord command Error (P2)" "${P2_ERR}"
    fi
    if [[ "$P3_ERR" != "0" && ! -z "$P3_ERR" ]] ; then
        _report -wts "Error: The third component of vrecord recording process gave an Error Code - ${P3_ERR}"
        _report -w "Consider reporting this or asking for help at https://github.com/amiaopensource/vrecord/issues"
        _writeingestlog "vrecord command Error (P3)" "${P3_ERR}"
    fi
fi

if [[ -f "${TC_TMP}" ]] ; then
    mv "${TC_TMP}" "${LOGDIR}/${FULL_OUTPUT_ID}_${TC_TYPE}${TIMECODELOGSUFFIX}"
fi

_writeingestlog "datetime_end" "$(_get_iso8601)"
trap _cleanup SIGHUP SIGINT SIGTERM

# qc tools process
if [[ "${QCTOOLSXML_CHOICE}" = "Yes, after recording" ]] ; then
    qcli -f signalstats+aphasemeter+astats+ssim -i "${VRECORD_OUTPUT}" -o "${QCXML}"
fi
if [[ "${QCTOOLSXML_CHOICE}" != "No" ]] ; then
    _report -d "Vrecord is analyzing your video file. Please be patient."
    if [[ -s "${QCXML}" ]] ; then
        if [[ "${PIXEL_FORMAT}" = "yuv422p10" ]] ; then
            SAT_OUTLIERS=$("${ZCAT_COMMAND}" "${QCXML}" | perl -nle 'print if not m{lavfi.(?!signalstats.SATMAX)}' | xmlstarlet sel -t -v "count(//tag[@key='lavfi.signalstats.SATMAX'][@value>496])" -n)
        elif [[ "${PIXEL_FORMAT}" = "uyvy422" ]] ; then
            SAT_OUTLIERS=$("${ZCAT_COMMAND}" "${QCXML}" | perl -nle 'print if not m{lavfi.(?!signalstats.SATMAX)}' | xmlstarlet sel -t -v "count(//tag[@key='lavfi.signalstats.SATMAX'][@value>124])" -n)
        fi
        AUD_OUTLIERS=$("${ZCAT_COMMAND}" "${QCXML}" | perl -nle 'print if not m{lavfi.(?!astats.Overall.Peak_level)}' | grep -v "tag key=\"lavfi.[^a]" | xmlstarlet sel -t -v "count(//tag[@key='lavfi.astats.Overall.Peak_level'][@value>=-0.01])" -n)
        BRNG_OUTLIERS=$("${ZCAT_COMMAND}" "${QCXML}" | perl -nle 'print if not m{lavfi.(?!signalstats.BRNG)}' | xmlstarlet sel -t -v "count(//tag[@key='lavfi.signalstats.BRNG'][@value>=0.03])" -n)
        AUDIO_PEAK=$("${ZCAT_COMMAND}" "${QCXML}" | grep lavfi.astats.Overall.Peak_level | cut -d '"' -f 4 | sort -n | tail -n 1)
        _writeingestlog "Peak Volume is (dB)" "${AUDIO_PEAK}"
        if "$GNUPLOT_INSTALLED" && "$QCLI_INSTALLED" ; then
            _report -d "Vrecord is generating graphs from the QCTools data. One moment please."
            _qcgraphimage "${QCXML}"
        fi
    else
        _report -w "qctools XML ${QCXML} is empty or does not exist!"
    fi
    if [[ "${SAT_OUTLIERS}" -gt "${SAT_OUTLIER_THRSHLD}" ]] ; then
        cowsay "$(_report -w "WARNING: Your video file contains ${SAT_OUTLIERS} frames with illegal saturation values. Your deck may require cleaning.")"
    fi
    if [[ "${AUD_OUTLIERS}" -gt "${AUD_OUTLIER_THRSHLD}" ]] ; then
        cowsay "$(_report -w "WARNING: Your video file contains ${AUD_OUTLIERS} frames with clipped audio levels.")"
    fi
    if [[ "${BRNG_OUTLIERS}" -gt "${BRNG_OUTLIER_THRSHLD}" ]] ; then
        cowsay "$(_report -w "WARNING: Your video file contains ${BRNG_OUTLIERS} frames with pixels out of broadcast range.")"
    fi
    _report -d "QCTools analysis is complete."
fi

# check for discontinuities in the Frame MD5s; if user chose not to use Frame MD5s, check for frame discontinuties in the FFmpeg file
if [[ "${FRAMEMD5_CHOICE}" = "Yes" ]] ; then
    PTS_DISCONTINUITY=$(cat "${FRAMEMD5NAME}" | grep -v "^#" | cut -d, -f3 | sed 's/ //g' | grep -v "^0$" | awk '{if($1!=p+1){if(p+1==$1-1){printf p+1" "}else{printf p+1"-"$1-1" "}}{p=$1}}')
    if [[ -z "${PTS_DISCONTINUITY}" ]] ; then
        _writeingestlog "PTS_DISCONTINUITY" "none"
    else
        _writeingestlog "PTS_DISCONTINUITY" "${PTS_DISCONTINUITY}"
        cowsay "$(_report -w "WARNING: There were presentation timestamp discontinuities in the file's frame MD5s for these frame ranges: ${PTS_DISCONTINUITY}. This error may indicate frames dropped by FFmpeg or vrecord. The file may have sync issues.")"
    fi
elif [[ "${FRAMEMD5_CHOICE}" = "No" ]] ; then
    FRAMES_ENCODED=$(cat "${LOGDIR}/${ID}"_ffmpeg_*.log | grep -w "frames encoded" | awk '{print $10}' | grep -m 1 [0-9])
    FRAMES_DECODED=$(cat "${LOGDIR}/${ID}"_ffmpeg_*.log | grep -w "frames decoded" | awk '{print $10}' | grep -m 1 [0-9])
    if [[ "${FRAMES_ENCODED}" -lt $((FRAMES_DECODED-1)) ]] ; then
        FRAMES_DISCREPANCY=$((FRAMES_DECODED-FRAMES_ENCODED))
        cowsay "$(_report -w "WARNING: There were presentation timestamp discontinuities found in the framemd5s. This error may indicate frames dropped by FFmpeg or vrecord. The file may have sync issues.")"
        _writeingestlog "ffmpeg_missing_frames" "${FRAMES_DISCREPANCY}"
    else
        _writeingestlog "ffmpeg_missing_frames" "None"
    fi
fi

# check for frames dropped in ffmpeg_input.log
DROPPED_FRAMES_INSTANCES=$(grep -c "Frames dropped" "${FULL_CAPTURE_LOG}")
DROPPED_FRAMES_FRAMENUMBERS=$(grep "Frames dropped" "${FULL_CAPTURE_LOG}" | awk '{print $6}' | sed 's/[(#)]//g')
if [[ "${DROPPED_FRAMES_INSTANCES}" -gt 0 ]] ; then
    cowsay "$(_report -w "WARNING: FFmpeg Decklink input reported dropped frames in the following ${DROPPED_FRAMES_INSTANCES} locations. This error may indicate an interrupted signal between hardware components. The file may be missing content. With decklink inputs, this cow recommends reviewing your settings in Desktop Video Setup and setting the video and audio inputs to match what those set in vrecord.")"
    for i in ${DROPPED_FRAMES_FRAMENUMBERS} ; do # do not quote this variable
        DROPPED_FRAMES_TIMESTAMPS+="$(_frames_to_hhmmss "${i}") "
    done
    _report -w "Dropped frames timestamps: ${DROPPED_FRAMES_TIMESTAMPS}"
    _writeingestlog "DROPPED_FRAMES_TIMESTAMPS" "${DROPPED_FRAMES_TIMESTAMPS}"
fi

# check for input buffer overrun error
BUFFER_OVERRUN=$(grep -c "Decklink input buffer overrun" "${FULL_CAPTURE_LOG}")
if [[ "${BUFFER_OVERRUN}" -gt 0 ]] ; then
    cowsay "$(_report -w "WARNING: FFmpeg Decklink input reported a buffer overrun. The file is likely missing frames or contains artifacts from the buffer overrun.")"
    _writeingestlog "Decklink input buffer overrun" "Yes"
fi

if [[ "${DEVICE_INPUT_CHOICE}" = 0 ]] ; then
    # policy checks with mediaconch
    if "$MEDIACONCH_INSTALLED" ; then
        if [[ "${VIDEO_CODEC_CHOICE}" = "Uncompressed Video" ]] ; then
            _report -d "Checking file conformance against uncompressed video policy..."
            STATUS=$(mediaconch -fx -p "${RESOURCE_PATH}/vrecord_policy_uncompressed.xml" "${VRECORD_OUTPUT}" | xmlstarlet sel -N mc="https://mediaarea.net/mediaconch" -t -v mc:MediaConch/mc:media/mc:policy/@outcome -n)
            if [[ "$STATUS" = "pass" ]] ; then
                _report -dt "File passed policy check for uncompressed video."
            elif [[ "$STATUS" = "fail" ]] ; then
                _report -wt "File did not pass vrecord policy check for uncompressed video and may not conform to digital preservation standards. Try another file?"
                mediaconch -fx -p "${RESOURCE_PATH}/vrecord_policy_uncompressed.xml" "${VRECORD_OUTPUT}" | xmlstarlet fo > "${DIR}/${FULL_OUTPUT_ID}_mediaconchreport.xml"
                _report -wt "See ${DIR}/${ID}${SUFFIX}_mediaconchreport.xml for a full MediaConch policy report."
            else
                mediaconch -p "${RESOURCE_PATH}/vrecord_policy_uncompressed.xml" "${VRECORD_OUTPUT}"
            fi
        elif [[ "${VIDEO_CODEC_CHOICE}" = "FFV1 version 3" ]] ; then
            _report -d "Checking file conformance against FFV1 video policy..."
            STATUS=$(mediaconch -fx -p "${RESOURCE_PATH}/vrecord_policy_ffv1.xml" "${VRECORD_OUTPUT}" | xmlstarlet sel -N mc="https://mediaarea.net/mediaconch" -t -v mc:MediaConch/mc:media/mc:policy/@outcome -n)
            if [[ "${STATUS}" = "pass" ]] ; then
                _report -dt "File passed policy check for FFV1 video."
            elif [[ "$STATUS" = "fail" ]] ; then
                _report -wt "File did not pass vrecord policy check for FFV1 video and may not conform to digital preservation standards. Try another file?"
                mediaconch -fx -p "${RESOURCE_PATH}/vrecord_policy_ffv1.xml" "${VRECORD_OUTPUT}" | xmlstarlet fo > "${DIR}/${FULL_OUTPUT_ID}_mediaconchreport.xml"
                _report -wt "See ${DIR}/${ID}${SUFFIX}_mediaconchreport.xml for a full MediaConch policy report."
            else
                mediaconch -p "${RESOURCE_PATH}/vrecord_policy_ffv1.xml" "${VRECORD_OUTPUT}"
            fi
        fi
    fi

    # embed logs in Matroska files
    if "$MKVPROPEDIT_INSTALLED" ; then
        if [[ "${CONTAINER_CHOICE}" = "Matroska" ]] && [[ "${EMBED_LOGS_CHOICE}" = "Yes" ]] ; then
            _report -d "Vrecord is attaching logs to your Matroska file:"
            mkvpropedit "${VRECORD_OUTPUT}" --attachment-description "Capture options selected by user during vrecord process" --add-attachment "${INGESTLOG}"
            mkvpropedit "${VRECORD_OUTPUT}" --attachment-description "Full FFmpeg output from vrecord capture process" --add-attachment "${FULL_CAPTURE_LOG}"
            if [[ "${QCTOOLSXML_CHOICE}" = "Yes" ]] ; then
                mkvpropedit "${VRECORD_OUTPUT}" --attachment-description "QCTools report from vrecord capture process (zipped XML)" --add-attachment "${QCXML}"
            fi
            _report -d "Vrecord is done attaching logs to your Matroska file!"
        fi
    fi
fi
